{"ast":null,"code":"// ========================================================================\n// REDA EMC Testing Tool - CSV Service\n// ========================================================================\n// Turner Engineering Corporation - Professional EMC Testing Support\n// \n// Service for CSV file processing, data parsing, and analysis\n// ========================================================================\nimport{BAND_DEFINITIONS,APP_CONFIG,ERROR_MESSAGES,DEFAULT_PEAK_DETECTION_OPTIONS,SUPPORTED_CSV_TYPES}from'../constants';// ========================================================================\n// CSV PARSING AND VALIDATION\n// ========================================================================\nexport class CsvService{/**\n   * Parse CSV file content and extract frequency/amplitude data\n   */static async parseCsvFile(file){const result={success:false,data:undefined,errors:[],warnings:[]};try{// Validate file type\nif(!this.isValidCsvFile(file)){result.errors.push(ERROR_MESSAGES.UNSUPPORTED_FILE_TYPE);return result;}// Validate file size\nif(file.size>APP_CONFIG.maxFileSize){result.errors.push(ERROR_MESSAGES.FILE_TOO_LARGE);return result;}// Parse CSV content\nconst csvText=await this.readFileAsText(file);const parseResult=await this.parseCsvText(csvText);if(!parseResult.success||!parseResult.data){result.errors.push(...parseResult.errors);return result;}result.success=true;result.data=parseResult.data;result.warnings=parseResult.warnings;}catch(error){result.errors.push(\"Failed to parse CSV file: \".concat(error instanceof Error?error.message:'Unknown error'));}return result;}/**\n   * Parse CSV text content\n   */static async parseCsvText(csvText){const result={success:false,data:undefined,errors:[],warnings:[]};try{// Find data start line (look for \"DATA\" marker)\nconst lines=csvText.split('\\n');let dataStartIndex=-1;for(let i=0;i<lines.length;i++){const line=lines[i].trim();if(line==='DATA'||line==='DATA,'){dataStartIndex=i+1;break;}}// If no DATA marker found, assume data starts from first line\nif(dataStartIndex===-1){dataStartIndex=0;result.warnings.push('No DATA marker found. Processing from first line.');}// Parse data lines\nconst dataPoints=[];let invalidRows=0;for(let i=dataStartIndex;i<lines.length;i++){const line=lines[i].trim();if(!line||line.startsWith('#')||line.startsWith('//')){continue;// Skip empty lines and comments\n}const parts=line.split(',');if(parts.length>=2){const frequency=this.parseNumber(parts[0]);const amplitude=this.parseNumber(parts[1]);if(!isNaN(frequency)&&!isNaN(amplitude)){dataPoints.push({frequency:frequency,// Hz\namplitude:amplitude// dBμV/m\n});}else{invalidRows++;}}else{invalidRows++;}}if(dataPoints.length===0){result.errors.push(ERROR_MESSAGES.NO_DATA_FOUND);return result;}if(invalidRows>0){result.warnings.push(\"\".concat(invalidRows,\" invalid rows were skipped\"));}// Sort by frequency\ndataPoints.sort((a,b)=>a.frequency-b.frequency);result.success=true;result.data=dataPoints;}catch(error){result.errors.push(\"Failed to parse CSV text: \".concat(error instanceof Error?error.message:'Unknown error'));}return result;}/**\n   * Analyze CSV file for band detection and validation\n   */static analyzeFile(file,csvData){const analysis={filename:file.name,band:null,frequencyRange:{min:0,max:0},dataPoints:0,isValid:false,errors:[]};try{// Basic file validation\nif(!this.isValidCsvFile(file)){analysis.errors.push('Invalid file type');return analysis;}if(file.size>APP_CONFIG.maxFileSize){analysis.errors.push('File too large');return analysis;}// If CSV data is provided, analyze it\nif(csvData&&csvData.length>0){const frequencies=csvData.map(point=>point.frequency/1e6);// Convert to MHz\nanalysis.frequencyRange.min=Math.min(...frequencies);analysis.frequencyRange.max=Math.max(...frequencies);analysis.dataPoints=csvData.length;analysis.band=this.detectBandFromFrequencyRange(analysis.frequencyRange.min,analysis.frequencyRange.max);analysis.isValid=true;}else{// Try to detect band from filename\nanalysis.band=this.detectBandFromFilename(file.name);}}catch(error){analysis.errors.push(\"Analysis failed: \".concat(error instanceof Error?error.message:'Unknown error'));}return analysis;}/**\n   * Create CSV overlay dataset from file\n   */static async createOverlayDataset(file,color,label){const result={success:false,data:undefined,errors:[],warnings:[]};try{const parseResult=await this.parseCsvFile(file);if(!parseResult.success||!parseResult.data){result.errors.push(...parseResult.errors);return result;}const data=parseResult.data;const frequencyData=data.map(point=>point.frequency/1e6);// Convert to MHz\nconst amplitudeData=data.map(point=>point.amplitude);const dataset={id:\"dataset_\".concat(Date.now(),\"_\").concat(Math.random().toString(36).substr(2,9)),filename:file.name,data:data,color:color,frequencyData:frequencyData,amplitudeData:amplitudeData,visible:true,label:label||file.name};result.success=true;result.data=dataset;result.warnings=parseResult.warnings;}catch(error){result.errors.push(\"Failed to create overlay dataset: \".concat(error instanceof Error?error.message:'Unknown error'));}return result;}// ========================================================================\n// PEAK DETECTION\n// ========================================================================\n/**\n   * Detect peaks in CSV data\n   */static detectPeaks(data){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:DEFAULT_PEAK_DETECTION_OPTIONS;if(data.length<3)return[];const peaks=[];const amplitudes=data.map(point=>point.amplitude);const frequencies=data.map(point=>point.frequency/1e6);// Convert to MHz\n// Find local maxima\nfor(let i=1;i<data.length-1;i++){const current=amplitudes[i];const prev=amplitudes[i-1];const next=amplitudes[i+1];// Check if it's a local maximum\nif(current>prev&&current>next&&current>=options.minHeight){const prominence=this.calculateProminence(amplitudes,i);if(prominence>=options.minProminence){// Check minimum distance from other peaks\nconst tooClose=peaks.some(peak=>Math.abs(peak.index-i)<options.minDistance);if(!tooClose){peaks.push({frequency:frequencies[i],amplitude:current,index:i,prominence:prominence});}}}}// Sort by prominence (highest first) and limit to maxPeaks\nreturn peaks.sort((a,b)=>b.prominence-a.prominence).slice(0,options.maxPeaks);}/**\n   * Calculate prominence of a peak\n   */static calculateProminence(amplitudes,peakIndex){const peakValue=amplitudes[peakIndex];let leftMin=peakValue;let rightMin=peakValue;// Search left for minimum\nfor(let i=peakIndex-1;i>=0;i--){if(amplitudes[i]<leftMin){leftMin=amplitudes[i];}if(amplitudes[i]>peakValue)break;}// Search right for minimum\nfor(let i=peakIndex+1;i<amplitudes.length;i++){if(amplitudes[i]<rightMin){rightMin=amplitudes[i];}if(amplitudes[i]>peakValue)break;}return peakValue-Math.max(leftMin,rightMin);}// ========================================================================\n// BAND DETECTION\n// ========================================================================\n/**\n   * Detect band from frequency range\n   */static detectBandFromFrequencyRange(minFreqMHz,maxFreqMHz){const bandEntries=Object.entries(BAND_DEFINITIONS);for(const[bandType,definition]of bandEntries){// Check if the frequency range overlaps with the band\nif(!(maxFreqMHz<definition.startMHz||minFreqMHz>definition.endMHz)){return bandType;}}return null;}/**\n   * Detect band from filename\n   */static detectBandFromFilename(filename){const upperFilename=filename.toUpperCase();// Look for band patterns in filename\nconst bandPatterns=[['B0',[/B0/i,/BAND\\s*0/i,/10\\s*KHZ/i,/160\\s*KHZ/i]],['B1',[/B1/i,/BAND\\s*1/i,/150\\s*KHZ/i,/650\\s*KHZ/i]],['B2',[/B2/i,/BAND\\s*2/i,/500\\s*KHZ/i,/3\\s*MHZ/i]],['B3',[/B3/i,/BAND\\s*3/i,/2\\.?5\\s*MHZ/i,/7\\.?5\\s*MHZ/i]],['B4',[/B4/i,/BAND\\s*4/i,/5\\s*MHZ/i,/30\\s*MHZ/i]],['B5',[/B5/i,/BAND\\s*5/i,/25\\s*MHZ/i,/325\\s*MHZ/i]],['B6',[/B6/i,/BAND\\s*6/i,/300\\s*MHZ/i,/1\\.?3\\s*GHZ/i]],['B7',[/B7/i,/BAND\\s*7/i,/1\\s*GHZ/i,/6\\s*GHZ/i]]];for(const[bandType,patterns]of bandPatterns){if(patterns.some(pattern=>pattern.test(upperFilename))){return bandType;}}return null;}// ========================================================================\n// UTILITY METHODS\n// ========================================================================\n/**\n   * Check if file is a valid CSV file\n   */static isValidCsvFile(file){return SUPPORTED_CSV_TYPES.includes(file.type)||file.name.toLowerCase().endsWith('.csv')||file.name.toLowerCase().endsWith('.txt');}/**\n   * Read file as text\n   */static readFileAsText(file){return new Promise((resolve,reject)=>{const reader=new FileReader();reader.onload=()=>resolve(reader.result);reader.onerror=()=>reject(new Error('Failed to read file'));reader.readAsText(file);});}/**\n   * Parse string to number with better error handling\n   */static parseNumber(str){if(!str||typeof str!=='string')return NaN;// Remove any whitespace and common units\nconst cleaned=str.trim().replace(/[^\\d.+eE-]/g,'')// Keep only digits, decimal, signs, and scientific notation\n.replace(/^0+/,'0');// Remove leading zeros but keep at least one\nreturn parseFloat(cleaned);}/**\n   * Generate nice axis ranges for plotting\n   */static calculateNiceRanges(minFreq,maxFreq,minAmp,maxAmp){// Add 5% padding to frequency range\nconst freqPadding=(maxFreq-minFreq)*0.05;const niceMinFreq=Math.max(0,minFreq-freqPadding);const niceMaxFreq=maxFreq+freqPadding;// Add 10% padding to amplitude range\nconst ampPadding=(maxAmp-minAmp)*0.1;const niceMinAmp=minAmp-ampPadding;const niceMaxAmp=maxAmp+ampPadding;return{frequency:{min:niceMinFreq,max:niceMaxFreq},amplitude:{min:niceMinAmp,max:niceMaxAmp}};}/**\n   * Filter data to a specific band range\n   */static filterDataToBand(data,band){const definition=BAND_DEFINITIONS[band];const startHz=definition.startMHz*1e6;const endHz=definition.endMHz*1e6;return data.filter(point=>point.frequency>=startHz&&point.frequency<=endHz);}/**\n   * Export CSV data to file\n   */static exportToCSV(datasets){let includeHeader=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(datasets.length===0)return'';let csvContent='';// Add header if requested\nif(includeHeader){csvContent+='# REDA EMC Testing Tool Export\\n';csvContent+=\"# Generated: \".concat(new Date().toISOString(),\"\\n\");csvContent+=\"# Datasets: \".concat(datasets.length,\"\\n\");csvContent+='#\\n';}// Add data header\nconst headers=['Frequency (Hz)','Amplitude (dBμV/m)','Dataset'];csvContent+=headers.join(',')+'\\n';// Add data\nfor(const dataset of datasets){for(const point of dataset.data){csvContent+=\"\".concat(point.frequency,\",\").concat(point.amplitude,\",\\\"\").concat(dataset.filename,\"\\\"\\n\");}}return csvContent;}/**\n   * Generate filename suggestions based on content\n   */static generateFilename(band,runId,timestamp){const parts=['reda_export'];if(band)parts.push(band.toLowerCase());if(runId)parts.push(runId);const date=timestamp||new Date();const dateStr=date.toISOString().split('T')[0];// YYYY-MM-DD\nparts.push(dateStr);return parts.join('_')+'.csv';}}","map":{"version":3,"names":["BAND_DEFINITIONS","APP_CONFIG","ERROR_MESSAGES","DEFAULT_PEAK_DETECTION_OPTIONS","SUPPORTED_CSV_TYPES","CsvService","parseCsvFile","file","result","success","data","undefined","errors","warnings","isValidCsvFile","push","UNSUPPORTED_FILE_TYPE","size","maxFileSize","FILE_TOO_LARGE","csvText","readFileAsText","parseResult","parseCsvText","error","concat","Error","message","lines","split","dataStartIndex","i","length","line","trim","dataPoints","invalidRows","startsWith","parts","frequency","parseNumber","amplitude","isNaN","NO_DATA_FOUND","sort","a","b","analyzeFile","csvData","analysis","filename","name","band","frequencyRange","min","max","isValid","frequencies","map","point","Math","detectBandFromFrequencyRange","detectBandFromFilename","createOverlayDataset","color","label","frequencyData","amplitudeData","dataset","id","Date","now","random","toString","substr","visible","detectPeaks","options","arguments","peaks","amplitudes","current","prev","next","minHeight","prominence","calculateProminence","minProminence","tooClose","some","peak","abs","index","minDistance","slice","maxPeaks","peakIndex","peakValue","leftMin","rightMin","minFreqMHz","maxFreqMHz","bandEntries","Object","entries","bandType","definition","startMHz","endMHz","upperFilename","toUpperCase","bandPatterns","patterns","pattern","test","includes","type","toLowerCase","endsWith","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","str","NaN","cleaned","replace","parseFloat","calculateNiceRanges","minFreq","maxFreq","minAmp","maxAmp","freqPadding","niceMinFreq","niceMaxFreq","ampPadding","niceMinAmp","niceMaxAmp","filterDataToBand","startHz","endHz","filter","exportToCSV","datasets","includeHeader","csvContent","toISOString","headers","join","generateFilename","runId","timestamp","date","dateStr"],"sources":["/Users/howardwang/Desktop/Turner Engineering/Software Product Design/reda-main/typescript-react-app/src/services/CsvService.ts"],"sourcesContent":["// ========================================================================\n// REDA EMC Testing Tool - CSV Service\n// ========================================================================\n// Turner Engineering Corporation - Professional EMC Testing Support\n// \n// Service for CSV file processing, data parsing, and analysis\n// ========================================================================\n\nimport {\n  CsvDataPoint,\n  CsvOverlayDataset,\n  FileAnalysis,\n  BandType,\n  ServiceResult,\n  DetectedPeak,\n  PeakDetectionOptions\n} from '../types';\nimport {\n  BAND_DEFINITIONS,\n  APP_CONFIG,\n  ERROR_MESSAGES,\n  DEFAULT_PEAK_DETECTION_OPTIONS,\n  SUPPORTED_CSV_TYPES\n} from '../constants';\n\n// ========================================================================\n// CSV PARSING AND VALIDATION\n// ========================================================================\n\nexport class CsvService {\n  /**\n   * Parse CSV file content and extract frequency/amplitude data\n   */\n  static async parseCsvFile(file: File): Promise<ServiceResult<CsvDataPoint[]>> {\n    const result: ServiceResult<CsvDataPoint[]> = {\n      success: false,\n      data: undefined,\n      errors: [],\n      warnings: []\n    };\n\n    try {\n      // Validate file type\n      if (!this.isValidCsvFile(file)) {\n        result.errors.push(ERROR_MESSAGES.UNSUPPORTED_FILE_TYPE);\n        return result;\n      }\n\n      // Validate file size\n      if (file.size > APP_CONFIG.maxFileSize) {\n        result.errors.push(ERROR_MESSAGES.FILE_TOO_LARGE);\n        return result;\n      }\n\n      // Parse CSV content\n      const csvText = await this.readFileAsText(file);\n      const parseResult = await this.parseCsvText(csvText);\n\n      if (!parseResult.success || !parseResult.data) {\n        result.errors.push(...parseResult.errors);\n        return result;\n      }\n\n      result.success = true;\n      result.data = parseResult.data;\n      result.warnings = parseResult.warnings;\n\n    } catch (error) {\n      result.errors.push(`Failed to parse CSV file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Parse CSV text content\n   */\n  static async parseCsvText(csvText: string): Promise<ServiceResult<CsvDataPoint[]>> {\n    const result: ServiceResult<CsvDataPoint[]> = {\n      success: false,\n      data: undefined,\n      errors: [],\n      warnings: []\n    };\n\n    try {\n      // Find data start line (look for \"DATA\" marker)\n      const lines = csvText.split('\\n');\n      let dataStartIndex = -1;\n\n      for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (line === 'DATA' || line === 'DATA,') {\n          dataStartIndex = i + 1;\n          break;\n        }\n      }\n\n      // If no DATA marker found, assume data starts from first line\n      if (dataStartIndex === -1) {\n        dataStartIndex = 0;\n        result.warnings.push('No DATA marker found. Processing from first line.');\n      }\n\n      // Parse data lines\n      const dataPoints: CsvDataPoint[] = [];\n      let invalidRows = 0;\n\n      for (let i = dataStartIndex; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line || line.startsWith('#') || line.startsWith('//')) {\n          continue; // Skip empty lines and comments\n        }\n\n        const parts = line.split(',');\n        if (parts.length >= 2) {\n          const frequency = this.parseNumber(parts[0]);\n          const amplitude = this.parseNumber(parts[1]);\n\n          if (!isNaN(frequency) && !isNaN(amplitude)) {\n            dataPoints.push({\n              frequency: frequency, // Hz\n              amplitude: amplitude  // dBμV/m\n            });\n          } else {\n            invalidRows++;\n          }\n        } else {\n          invalidRows++;\n        }\n      }\n\n      if (dataPoints.length === 0) {\n        result.errors.push(ERROR_MESSAGES.NO_DATA_FOUND);\n        return result;\n      }\n\n      if (invalidRows > 0) {\n        result.warnings.push(`${invalidRows} invalid rows were skipped`);\n      }\n\n      // Sort by frequency\n      dataPoints.sort((a, b) => a.frequency - b.frequency);\n\n      result.success = true;\n      result.data = dataPoints;\n\n    } catch (error) {\n      result.errors.push(`Failed to parse CSV text: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Analyze CSV file for band detection and validation\n   */\n  static analyzeFile(file: File, csvData?: CsvDataPoint[]): FileAnalysis {\n    const analysis: FileAnalysis = {\n      filename: file.name,\n      band: null,\n      frequencyRange: { min: 0, max: 0 },\n      dataPoints: 0,\n      isValid: false,\n      errors: []\n    };\n\n    try {\n      // Basic file validation\n      if (!this.isValidCsvFile(file)) {\n        analysis.errors.push('Invalid file type');\n        return analysis;\n      }\n\n      if (file.size > APP_CONFIG.maxFileSize) {\n        analysis.errors.push('File too large');\n        return analysis;\n      }\n\n      // If CSV data is provided, analyze it\n      if (csvData && csvData.length > 0) {\n        const frequencies = csvData.map(point => point.frequency / 1e6); // Convert to MHz\n        analysis.frequencyRange.min = Math.min(...frequencies);\n        analysis.frequencyRange.max = Math.max(...frequencies);\n        analysis.dataPoints = csvData.length;\n        analysis.band = this.detectBandFromFrequencyRange(\n          analysis.frequencyRange.min,\n          analysis.frequencyRange.max\n        );\n        analysis.isValid = true;\n      } else {\n        // Try to detect band from filename\n        analysis.band = this.detectBandFromFilename(file.name);\n      }\n\n    } catch (error) {\n      analysis.errors.push(`Analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    return analysis;\n  }\n\n  /**\n   * Create CSV overlay dataset from file\n   */\n  static async createOverlayDataset(\n    file: File,\n    color: string,\n    label?: string\n  ): Promise<ServiceResult<CsvOverlayDataset>> {\n    const result: ServiceResult<CsvOverlayDataset> = {\n      success: false,\n      data: undefined,\n      errors: [],\n      warnings: []\n    };\n\n    try {\n      const parseResult = await this.parseCsvFile(file);\n      \n      if (!parseResult.success || !parseResult.data) {\n        result.errors.push(...parseResult.errors);\n        return result;\n      }\n\n      const data = parseResult.data;\n      const frequencyData = data.map(point => point.frequency / 1e6); // Convert to MHz\n      const amplitudeData = data.map(point => point.amplitude);\n\n      const dataset: CsvOverlayDataset = {\n        id: `dataset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        filename: file.name,\n        data: data,\n        color: color,\n        frequencyData: frequencyData,\n        amplitudeData: amplitudeData,\n        visible: true,\n        label: label || file.name\n      };\n\n      result.success = true;\n      result.data = dataset;\n      result.warnings = parseResult.warnings;\n\n    } catch (error) {\n      result.errors.push(`Failed to create overlay dataset: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    return result;\n  }\n\n  // ========================================================================\n  // PEAK DETECTION\n  // ========================================================================\n\n  /**\n   * Detect peaks in CSV data\n   */\n  static detectPeaks(\n    data: CsvDataPoint[],\n    options: PeakDetectionOptions = DEFAULT_PEAK_DETECTION_OPTIONS\n  ): DetectedPeak[] {\n    if (data.length < 3) return [];\n\n    const peaks: DetectedPeak[] = [];\n    const amplitudes = data.map(point => point.amplitude);\n    const frequencies = data.map(point => point.frequency / 1e6); // Convert to MHz\n\n    // Find local maxima\n    for (let i = 1; i < data.length - 1; i++) {\n      const current = amplitudes[i];\n      const prev = amplitudes[i - 1];\n      const next = amplitudes[i + 1];\n\n      // Check if it's a local maximum\n      if (current > prev && current > next && current >= options.minHeight) {\n        const prominence = this.calculateProminence(amplitudes, i);\n        \n        if (prominence >= options.minProminence) {\n          // Check minimum distance from other peaks\n          const tooClose = peaks.some(peak => \n            Math.abs(peak.index - i) < options.minDistance\n          );\n\n          if (!tooClose) {\n            peaks.push({\n              frequency: frequencies[i],\n              amplitude: current,\n              index: i,\n              prominence: prominence\n            });\n          }\n        }\n      }\n    }\n\n    // Sort by prominence (highest first) and limit to maxPeaks\n    return peaks\n      .sort((a, b) => b.prominence - a.prominence)\n      .slice(0, options.maxPeaks);\n  }\n\n  /**\n   * Calculate prominence of a peak\n   */\n  private static calculateProminence(amplitudes: number[], peakIndex: number): number {\n    const peakValue = amplitudes[peakIndex];\n    let leftMin = peakValue;\n    let rightMin = peakValue;\n\n    // Search left for minimum\n    for (let i = peakIndex - 1; i >= 0; i--) {\n      if (amplitudes[i] < leftMin) {\n        leftMin = amplitudes[i];\n      }\n      if (amplitudes[i] > peakValue) break;\n    }\n\n    // Search right for minimum\n    for (let i = peakIndex + 1; i < amplitudes.length; i++) {\n      if (amplitudes[i] < rightMin) {\n        rightMin = amplitudes[i];\n      }\n      if (amplitudes[i] > peakValue) break;\n    }\n\n    return peakValue - Math.max(leftMin, rightMin);\n  }\n\n  // ========================================================================\n  // BAND DETECTION\n  // ========================================================================\n\n  /**\n   * Detect band from frequency range\n   */\n  static detectBandFromFrequencyRange(minFreqMHz: number, maxFreqMHz: number): BandType | null {\n    const bandEntries = Object.entries(BAND_DEFINITIONS) as [BandType, typeof BAND_DEFINITIONS[BandType]][];\n    \n    for (const [bandType, definition] of bandEntries) {\n      // Check if the frequency range overlaps with the band\n      if (!(maxFreqMHz < definition.startMHz || minFreqMHz > definition.endMHz)) {\n        return bandType;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Detect band from filename\n   */\n  static detectBandFromFilename(filename: string): BandType | null {\n    const upperFilename = filename.toUpperCase();\n    \n    // Look for band patterns in filename\n    const bandPatterns: [BandType, RegExp[]][] = [\n      ['B0', [/B0/i, /BAND\\s*0/i, /10\\s*KHZ/i, /160\\s*KHZ/i]],\n      ['B1', [/B1/i, /BAND\\s*1/i, /150\\s*KHZ/i, /650\\s*KHZ/i]],\n      ['B2', [/B2/i, /BAND\\s*2/i, /500\\s*KHZ/i, /3\\s*MHZ/i]],\n      ['B3', [/B3/i, /BAND\\s*3/i, /2\\.?5\\s*MHZ/i, /7\\.?5\\s*MHZ/i]],\n      ['B4', [/B4/i, /BAND\\s*4/i, /5\\s*MHZ/i, /30\\s*MHZ/i]],\n      ['B5', [/B5/i, /BAND\\s*5/i, /25\\s*MHZ/i, /325\\s*MHZ/i]],\n      ['B6', [/B6/i, /BAND\\s*6/i, /300\\s*MHZ/i, /1\\.?3\\s*GHZ/i]],\n      ['B7', [/B7/i, /BAND\\s*7/i, /1\\s*GHZ/i, /6\\s*GHZ/i]]\n    ];\n\n    for (const [bandType, patterns] of bandPatterns) {\n      if (patterns.some(pattern => pattern.test(upperFilename))) {\n        return bandType;\n      }\n    }\n\n    return null;\n  }\n\n  // ========================================================================\n  // UTILITY METHODS\n  // ========================================================================\n\n  /**\n   * Check if file is a valid CSV file\n   */\n  static isValidCsvFile(file: File): boolean {\n    return SUPPORTED_CSV_TYPES.includes(file.type) || \n           file.name.toLowerCase().endsWith('.csv') ||\n           file.name.toLowerCase().endsWith('.txt');\n  }\n\n  /**\n   * Read file as text\n   */\n  static readFileAsText(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = () => resolve(reader.result as string);\n      reader.onerror = () => reject(new Error('Failed to read file'));\n      reader.readAsText(file);\n    });\n  }\n\n  /**\n   * Parse string to number with better error handling\n   */\n  private static parseNumber(str: string): number {\n    if (!str || typeof str !== 'string') return NaN;\n    \n    // Remove any whitespace and common units\n    const cleaned = str.trim()\n      .replace(/[^\\d.+eE-]/g, '') // Keep only digits, decimal, signs, and scientific notation\n      .replace(/^0+/, '0'); // Remove leading zeros but keep at least one\n    \n    return parseFloat(cleaned);\n  }\n\n  /**\n   * Generate nice axis ranges for plotting\n   */\n  static calculateNiceRanges(\n    minFreq: number,\n    maxFreq: number,\n    minAmp: number,\n    maxAmp: number\n  ): {\n    frequency: { min: number; max: number };\n    amplitude: { min: number; max: number };\n  } {\n    // Add 5% padding to frequency range\n    const freqPadding = (maxFreq - minFreq) * 0.05;\n    const niceMinFreq = Math.max(0, minFreq - freqPadding);\n    const niceMaxFreq = maxFreq + freqPadding;\n\n    // Add 10% padding to amplitude range\n    const ampPadding = (maxAmp - minAmp) * 0.1;\n    const niceMinAmp = minAmp - ampPadding;\n    const niceMaxAmp = maxAmp + ampPadding;\n\n    return {\n      frequency: { min: niceMinFreq, max: niceMaxFreq },\n      amplitude: { min: niceMinAmp, max: niceMaxAmp }\n    };\n  }\n\n  /**\n   * Filter data to a specific band range\n   */\n  static filterDataToBand(data: CsvDataPoint[], band: BandType): CsvDataPoint[] {\n    const definition = BAND_DEFINITIONS[band];\n    const startHz = definition.startMHz * 1e6;\n    const endHz = definition.endMHz * 1e6;\n\n    return data.filter(point => \n      point.frequency >= startHz && point.frequency <= endHz\n    );\n  }\n\n  /**\n   * Export CSV data to file\n   */\n  static exportToCSV(\n    datasets: CsvOverlayDataset[],\n    includeHeader: boolean = true\n  ): string {\n    if (datasets.length === 0) return '';\n\n    let csvContent = '';\n\n    // Add header if requested\n    if (includeHeader) {\n      csvContent += '# REDA EMC Testing Tool Export\\n';\n      csvContent += `# Generated: ${new Date().toISOString()}\\n`;\n      csvContent += `# Datasets: ${datasets.length}\\n`;\n      csvContent += '#\\n';\n    }\n\n    // Add data header\n    const headers = ['Frequency (Hz)', 'Amplitude (dBμV/m)', 'Dataset'];\n    csvContent += headers.join(',') + '\\n';\n\n    // Add data\n    for (const dataset of datasets) {\n      for (const point of dataset.data) {\n        csvContent += `${point.frequency},${point.amplitude},\"${dataset.filename}\"\\n`;\n      }\n    }\n\n    return csvContent;\n  }\n\n  /**\n   * Generate filename suggestions based on content\n   */\n  static generateFilename(\n    band?: BandType,\n    runId?: string,\n    timestamp?: Date\n  ): string {\n    const parts: string[] = ['reda_export'];\n    \n    if (band) parts.push(band.toLowerCase());\n    if (runId) parts.push(runId);\n    \n    const date = timestamp || new Date();\n    const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD\n    parts.push(dateStr);\n    \n    return parts.join('_') + '.csv';\n  }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}