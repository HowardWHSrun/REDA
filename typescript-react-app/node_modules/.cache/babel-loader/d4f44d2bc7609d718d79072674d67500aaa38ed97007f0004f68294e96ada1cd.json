{"ast":null,"code":"// ========================================================================\n// REDA EMC Testing Tool - Noise Analysis Service\n// ========================================================================\n// Turner Engineering Corporation - Professional EMC Testing Support\n// \n// Service for analyzing signal noisiness and calculating noisiness indices\n// ========================================================================\n// ========================================================================\n// NOISE ANALYSIS INTERFACES\n// ========================================================================\n// ========================================================================\n// NOISE ANALYSIS SERVICE\n// ========================================================================\nexport class NoiseAnalysisService{/**\n   * Calculate comprehensive noisiness index for signal data\n   */static calculateNoisinessIndex(data){let filename=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'unknown';if(!data||data.length<10){// Calculate average amplitude even with limited data if possible\nconst amplitudes=(data===null||data===void 0?void 0:data.map(point=>point.amplitude).filter(amp=>isFinite(amp)))||[];const averageAmplitude=amplitudes.length>0?this.calculateAverageAmplitudeScore(amplitudes):0;const fallbackScore=amplitudes.length>0?Math.round(averageAmplitude*95+5):50;// 95% average amplitude, 5% base\nreturn{filename,noisinessIndex:fallbackScore,metrics:{averageAmplitude,varianceScore:0,peakToRmsRatio:0,spectralFlatness:0,highFreqContent:0,smallPeakDensity:0,overallNoisiness:fallbackScore},confidence:'low',category:'moderate'};}const amplitudes=data.map(point=>point.amplitude).filter(amp=>isFinite(amp));const frequencies=data.map(point=>point.frequency).filter(freq=>isFinite(freq));// Early validation - if we don't have enough valid data, use simplified calculation\nif(amplitudes.length<10){const averageAmplitude=this.calculateAverageAmplitudeScore(amplitudes);const simpleVariance=this.calculateSimpleNoisiness(amplitudes);// Almost entirely based on average amplitude (95%) with minimal variance (5%)\nconst combinedScore=averageAmplitude*0.95+simpleVariance/100*0.05;const finalScore=Math.round(combinedScore*100);return{filename,noisinessIndex:finalScore,metrics:{averageAmplitude,varianceScore:simpleVariance/100,peakToRmsRatio:0.5,spectralFlatness:0.5,highFreqContent:0.5,smallPeakDensity:0.5,overallNoisiness:finalScore},confidence:'low',category:this.categorizeNoisiness(finalScore)};}// Calculate enhanced metrics for better discrimination\nconst averageAmplitude=this.calculateAverageAmplitudeScore(amplitudes);const varianceScore=this.calculateVarianceScore(amplitudes);const peakToRmsRatio=this.calculatePeakToRmsRatio(amplitudes);const spectralFlatness=this.calculateSpectralFlatness(amplitudes);const highFreqContent=this.calculateHighFrequencyContent(data);const smallPeakDensity=this.calculateSmallPeakDensity(amplitudes);// Additional discriminating metrics\nconst signalSmoothness=this.calculateSignalSmoothness(amplitudes);const dynamicRange=this.calculateDynamicRange(amplitudes);// Enhanced weighted combination prioritizing average amplitude for noisiness\nconst overallNoisiness=this.combineEnhancedMetrics({averageAmplitude,varianceScore,peakToRmsRatio,spectralFlatness,highFreqContent,smallPeakDensity,signalSmoothness,dynamicRange});const metrics={averageAmplitude,varianceScore,peakToRmsRatio,spectralFlatness,highFreqContent,smallPeakDensity,overallNoisiness};// Ensure the final noisiness index is finite and within bounds\nconst finalNoisiness=isFinite(overallNoisiness)?Math.round(Math.max(0,Math.min(100,overallNoisiness))):50;return{filename,noisinessIndex:finalNoisiness,metrics,confidence:this.assessConfidence(data.length,frequencies),category:this.categorizeNoisiness(finalNoisiness)};}/**\n   * Calculate average amplitude score (0-1, higher = higher average amplitude = noisier)\n   * This is the primary metric for determining noisiness based on average amplitude values\n   */static calculateAverageAmplitudeScore(amplitudes){if(amplitudes.length===0)return 0;// Filter out any non-finite values\nconst validAmplitudes=amplitudes.filter(amp=>isFinite(amp));if(validAmplitudes.length===0)return 0;// Calculate simple average amplitude\nconst averageAmplitude=validAmplitudes.reduce((sum,val)=>sum+val,0)/validAmplitudes.length;if(!isFinite(averageAmplitude))return 0;// Normalize average amplitude to 0-1 scale\n// EMC data typically ranges from very low (quiet) to high (noisy) amplitudes\n// We use a sigmoid function to map average amplitude to noisiness score\n// Assume amplitudes typically range from -80dB to +20dB, with higher values being noisier\nconst minExpectedAmplitude=-80;// dB - very quiet signal\nconst maxExpectedAmplitude=20;// dB - very noisy signal\n// Normalize to 0-1 range\nconst normalizedAmplitude=(averageAmplitude-minExpectedAmplitude)/(maxExpectedAmplitude-minExpectedAmplitude);// Apply sigmoid transformation for smooth transition\n// Values closer to maxExpectedAmplitude will be closer to 1 (noisier)\nconst clampedNormalized=Math.max(0,Math.min(1,normalizedAmplitude));// Use a sigmoid to enhance the separation between different amplitude levels\nconst sigmoidInput=(clampedNormalized-0.5)*6;// Scale for steeper curve\nconst sigmoidOutput=1/(1+Math.exp(-sigmoidInput));return isFinite(sigmoidOutput)?sigmoidOutput:0.5;}/**\n   * Calculate adaptive threshold based on signal characteristics\n   */static calculateAdaptiveThreshold(amplitudes){if(amplitudes.length===0)return 10;const sorted=[...amplitudes].sort((a,b)=>a-b);const q1=sorted[Math.floor(amplitudes.length*0.25)];const q3=sorted[Math.floor(amplitudes.length*0.75)];const iqr=q3-q1;// Adaptive threshold based on interquartile range\n// Clean signals typically have small IQR, noisy signals have large IQR\nreturn Math.max(3,Math.min(25,iqr*2+5));}/**\n   * Enhanced signal smoothness analysis\n   */static calculateSignalSmoothness(amplitudes){if(amplitudes.length<3)return 0;let totalVariation=0;for(let i=1;i<amplitudes.length-1;i++){// Second derivative approximation (measure of \"jaggedness\")\nconst secondDerivative=amplitudes[i+1]-2*amplitudes[i]+amplitudes[i-1];totalVariation+=Math.abs(secondDerivative);}const avgVariation=totalVariation/(amplitudes.length-2);// Sigmoid transformation for better separation\nreturn 1/(1+Math.exp(-0.5*(avgVariation-3)));}/**\n   * Dynamic range analysis\n   */static calculateDynamicRange(amplitudes){if(amplitudes.length===0)return 0;const sorted=[...amplitudes].sort((a,b)=>a-b);const min=sorted[0];const max=sorted[sorted.length-1];const range=max-min;// Very clean signals often have consistent levels (low range)\n// Very noisy signals have extreme variations (high range)\nconst normalizedRange=Math.min(range/50,1);// Assume 50dB max reasonable range\nreturn normalizedRange;}/**\n   * Simple noisiness calculation for cases with limited data\n   * Now almost entirely based on average amplitude (95%)\n   */static calculateSimpleNoisiness(amplitudes){if(amplitudes.length===0)return 50;// Calculate average amplitude score (dominant factor)\nconst averageAmplitudeScore=this.calculateAverageAmplitudeScore(amplitudes);// Simple standard deviation based calculation (minimal factor)\nconst mean=amplitudes.reduce((sum,val)=>sum+val,0)/amplitudes.length;const variance=amplitudes.reduce((sum,val)=>sum+Math.pow(val-mean,2),0)/amplitudes.length;const stdDev=Math.sqrt(variance);// Enhanced scaling with sigmoid for better separation\nconst normalizedStdDev=stdDev/8;// Adaptive to typical EMC data\nconst varianceScore=100/(1+Math.exp(-2*(normalizedStdDev-1)));const varianceNormalized=Math.max(5,Math.min(95,varianceScore))/100;// Almost entirely based on average amplitude (95%) with minimal variance (5%)\nconst combinedScore=averageAmplitudeScore*0.95+varianceNormalized*0.05;const finalScore=Math.round(combinedScore*100);return Math.max(5,Math.min(95,finalScore));}/**\n   * Calculate variance-based noise score with adaptive scaling\n   */static calculateVarianceScore(amplitudes){if(amplitudes.length===0)return 0;// Filter out any non-finite values\nconst validAmplitudes=amplitudes.filter(amp=>isFinite(amp));if(validAmplitudes.length===0)return 0;const mean=validAmplitudes.reduce((sum,val)=>sum+val,0)/validAmplitudes.length;const variance=validAmplitudes.reduce((sum,val)=>sum+Math.pow(val-mean,2),0)/validAmplitudes.length;const stdDev=Math.sqrt(variance);// Enhanced adaptive scaling based on signal characteristics\n// Use sigmoid function for better separation\nconst adaptiveThreshold=this.calculateAdaptiveThreshold(validAmplitudes);const normalizedStdDev=stdDev/adaptiveThreshold;// Sigmoid transformation for better dynamic range (0-1)\nconst score=1/(1+Math.exp(-3*(normalizedStdDev-1)));return isFinite(score)?score:0;}/**\n   * Enhanced peak-to-RMS analysis with crest factor and distribution analysis\n   */static calculatePeakToRmsRatio(amplitudes){if(amplitudes.length===0)return 0;// Filter out any non-finite values\nconst validAmplitudes=amplitudes.filter(amp=>isFinite(amp));if(validAmplitudes.length===0)return 0;const peak=Math.max(...validAmplitudes);const rms=Math.sqrt(validAmplitudes.reduce((sum,val)=>sum+val*val,0)/validAmplitudes.length);if(!isFinite(peak)||!isFinite(rms)||rms===0)return 0;const crestFactor=peak/rms;if(!isFinite(crestFactor))return 0;// Enhanced analysis: combine crest factor with distribution characteristics\nconst mean=validAmplitudes.reduce((sum,val)=>sum+val,0)/validAmplitudes.length;const skewness=this.calculateSkewness(validAmplitudes,mean);// Clean signals: high crest factor + low skewness\n// Noisy signals: low crest factor + high skewness\nconst crestScore=1/(1+Math.exp(-0.5*(crestFactor-4)));// Sigmoid around crest factor of 4\nconst skewnessScore=Math.abs(skewness)/3;// Normalize skewness influence\n// Combined score (inverted because lower = more noise for final calculation)\nconst combinedScore=crestScore*0.7+(1-skewnessScore)*0.3;return Math.max(0,Math.min(1,combinedScore));}/**\n   * Calculate skewness of amplitude distribution\n   */static calculateSkewness(amplitudes,mean){if(amplitudes.length===0)return 0;const variance=amplitudes.reduce((sum,val)=>sum+Math.pow(val-mean,2),0)/amplitudes.length;const stdDev=Math.sqrt(variance);if(stdDev===0)return 0;const skewness=amplitudes.reduce((sum,val)=>sum+Math.pow((val-mean)/stdDev,3),0)/amplitudes.length;return isFinite(skewness)?skewness:0;}/**\n   * Calculate spectral flatness (0-1, higher = flatter/noisier)\n   */static calculateSpectralFlatness(amplitudes){if(amplitudes.length===0)return 0;// Convert to linear scale for calculation, ensuring no zero values\nconst linearAmplitudes=amplitudes.map(amp=>{const linear=Math.pow(10,amp/20);return Math.max(linear,1e-12);// Prevent zero values\n});// Calculate geometric mean using log-space to avoid overflow/underflow\nconst logSum=linearAmplitudes.reduce((sum,val)=>{const logVal=Math.log(val);return sum+(isFinite(logVal)?logVal:-27.6);// log(1e-12) â‰ˆ -27.6\n},0);const geometricMean=Math.exp(logSum/linearAmplitudes.length);// Arithmetic mean\nconst arithmeticMean=linearAmplitudes.reduce((sum,val)=>sum+val,0)/linearAmplitudes.length;// Ensure we don't divide by zero and result is finite\nif(!isFinite(geometricMean)||!isFinite(arithmeticMean)||arithmeticMean===0){return 0;}const flatness=geometricMean/arithmeticMean;return isFinite(flatness)?Math.min(flatness,1):0;}/**\n   * Calculate high-frequency content ratio\n   */static calculateHighFrequencyContent(data){if(data.length<4)return 0;// Filter out any points with non-finite values\nconst validData=data.filter(point=>isFinite(point.frequency)&&isFinite(point.amplitude));if(validData.length<4)return 0;const sortedByFreq=[...validData].sort((a,b)=>a.frequency-b.frequency);const totalRange=sortedByFreq[sortedByFreq.length-1].frequency-sortedByFreq[0].frequency;if(totalRange===0||!isFinite(totalRange))return 0;// Define \"high frequency\" as top 25% of the frequency range\nconst highFreqThreshold=sortedByFreq[0].frequency+totalRange*0.75;const highFreqPoints=validData.filter(point=>point.frequency>=highFreqThreshold);const lowFreqPoints=validData.filter(point=>point.frequency<highFreqThreshold);if(lowFreqPoints.length===0||highFreqPoints.length===0)return 0;const highFreqMean=highFreqPoints.reduce((sum,p)=>sum+p.amplitude,0)/highFreqPoints.length;const lowFreqMean=lowFreqPoints.reduce((sum,p)=>sum+p.amplitude,0)/lowFreqPoints.length;if(!isFinite(highFreqMean)||!isFinite(lowFreqMean)||lowFreqMean===0)return 0;// High frequency content relative to low frequency content\nconst ratio=highFreqMean/lowFreqMean;if(!isFinite(ratio))return 0;// Normalize to 0-1 scale - higher ratio suggests more high-freq noise\nconst score=Math.min(Math.max(0,(ratio-0.5)/1.5),1);return isFinite(score)?score:0;}/**\n   * Calculate density of small peaks (noise spikes)\n   */static calculateSmallPeakDensity(amplitudes){if(amplitudes.length<5)return 0;// Filter out any non-finite values\nconst validAmplitudes=amplitudes.filter(amp=>isFinite(amp));if(validAmplitudes.length<5)return 0;let peakCount=0;const threshold=2;// dB threshold for considering a peak\nfor(let i=2;i<validAmplitudes.length-2;i++){const current=validAmplitudes[i];const leftAvg=(validAmplitudes[i-1]+validAmplitudes[i-2])/2;const rightAvg=(validAmplitudes[i+1]+validAmplitudes[i+2])/2;// Ensure all values are finite\nif(!isFinite(current)||!isFinite(leftAvg)||!isFinite(rightAvg))continue;// Check if current point is a local peak above threshold\nif(current>leftAvg+threshold&&current>rightAvg+threshold){peakCount++;}}// Density of peaks per 100 data points\nconst density=peakCount/validAmplitudes.length*100;if(!isFinite(density))return 0;// Normalize to 0-1 scale - more peaks suggest more noise\nconst score=Math.min(density/10,1);// Assume 10 peaks per 100 points = very noisy\nreturn isFinite(score)?score:0;}/**\n   * Enhanced metric combination with better discrimination\n   */static combineEnhancedMetrics(metrics){// Simplified weighting - average amplitude is now the dominant factor\nconst weights={averageAmplitude:0.95,// 95% - average amplitude (DOMINANT factor)\nvarianceScore:0.02,// 2% - minimal variance influence\npeakToRmsRatio:0.01,// 1% - minimal peak ratio influence\nspectralFlatness:0.01,// 1% - minimal spectral influence\nhighFreqContent:0.005,// 0.5% - minimal high-freq influence\nsmallPeakDensity:0.005,// 0.5% - minimal peak density influence\nsignalSmoothness:0.0,// 0% - disabled\ndynamicRange:0.0// 0% - disabled\n};// Ensure all metric values are finite before combining\nconst safeAverageAmplitude=isFinite(metrics.averageAmplitude)?metrics.averageAmplitude:0.5;const safeVariance=isFinite(metrics.varianceScore)?metrics.varianceScore:0.5;const safePeakRms=isFinite(metrics.peakToRmsRatio)?metrics.peakToRmsRatio:0.5;const safeFlatness=isFinite(metrics.spectralFlatness)?metrics.spectralFlatness:0.5;const safeHighFreq=isFinite(metrics.highFreqContent)?metrics.highFreqContent:0.5;const safePeakDensity=isFinite(metrics.smallPeakDensity)?metrics.smallPeakDensity:0.5;const safeSmoothness=isFinite(metrics.signalSmoothness)?metrics.signalSmoothness:0.5;const safeDynamicRange=isFinite(metrics.dynamicRange)?metrics.dynamicRange:0.5;const weightedSum=safeAverageAmplitude*weights.averageAmplitude+safeVariance*weights.varianceScore+safePeakRms*weights.peakToRmsRatio+safeFlatness*weights.spectralFlatness+safeHighFreq*weights.highFreqContent+safePeakDensity*weights.smallPeakDensity+safeSmoothness*weights.signalSmoothness+safeDynamicRange*weights.dynamicRange;// Apply final sigmoid transformation for enhanced separation\n// This spreads out the middle values more effectively\nconst sigmoidInput=(weightedSum-0.5)*4;// Scale and center around 0\nconst sigmoidOutput=1/(1+Math.exp(-sigmoidInput));// Convert to 0-100 scale with enhanced dynamic range\nconst result=sigmoidOutput*100;return isFinite(result)?Math.max(1,Math.min(99,result)):50;}/**\n   * Assess confidence in the noisiness calculation\n   */static assessConfidence(dataLength,frequencies){const freqRange=Math.max(...frequencies)-Math.min(...frequencies);if(dataLength>=1000&&freqRange>0)return'high';if(dataLength>=100&&freqRange>0)return'medium';return'low';}/**\n   * Categorize noisiness level for 1-10 scale\n   */static categorizeNoisiness(noisiness){if(noisiness<=2)return'very_quiet';if(noisiness<=4)return'quiet';if(noisiness<=6)return'moderate';if(noisiness<=8)return'noisy';return'very_noisy';}/**\n   * Get color for noisiness visualization (1-10 scale)\n   */static getNoisinessColor(noisiness){if(noisiness<=2)return'#2ecc71';// Green - very quiet\nif(noisiness<=4)return'#27ae60';// Dark green - quiet  \nif(noisiness<=6)return'#f39c12';// Orange - moderate\nif(noisiness<=8)return'#e67e22';// Dark orange - noisy\nreturn'#e74c3c';// Red - very noisy\n}/**\n   * Get emoji for noisiness level (1-10 scale)\n   */static getNoisinessEmoji(noisiness){if(noisiness<=2)return'ðŸ”‡';// Very quiet\nif(noisiness<=4)return'ðŸ”‰';// Quiet\nif(noisiness<=6)return'ðŸ”Š';// Moderate\nif(noisiness<=8)return'ðŸ“¢';// Noisy\nreturn'ðŸš¨';// Very noisy\n}/**\n   * Get text description for noisiness level (1-10 scale)\n   */static getNoisinessDescription(noisiness){if(noisiness<=2)return'Very Quiet';if(noisiness<=4)return'Quiet';if(noisiness<=6)return'Moderate';if(noisiness<=8)return'Noisy';return'Very Noisy';}/**\n   * Batch analyze multiple files and rank by noisiness\n   */static async batchAnalyzeAndRank(files){const results=files.map(file=>this.calculateNoisinessIndex(file.data,file.filename));// Sort by noisiness (highest first)\nreturn results.sort((a,b)=>b.noisinessIndex-a.noisinessIndex);}/**\n   * Calculate band-relative noisiness index for multiple files in the same band\n   * This method compares files within their band and scales from 0-100\n   * @param filesData Array of files with their data and band information\n   * @returns Array of results with relative noisiness (0-100 within band)\n   */static calculateBandRelativeNoisiness(filesData){if(filesData.length===0)return[];// Group files by band\nconst filesByBand=filesData.reduce((groups,file)=>{const band=file.band||'Unknown';if(!groups[band])groups[band]=[];groups[band].push(file);return groups;},{});const allResults=[];// Process each band separately\nfor(const[band,bandFiles]of Object.entries(filesByBand)){console.log(\"\\uD83C\\uDFAF Processing \".concat(bandFiles.length,\" files in band \").concat(band));// Calculate average amplitude for each file in this band\nconst fileAmplitudes=bandFiles.map(file=>{const amplitudes=file.data.map(point=>point.amplitude).filter(amp=>isFinite(amp));const avgAmplitude=amplitudes.length>0?amplitudes.reduce((sum,val)=>sum+val,0)/amplitudes.length:-999;return{file,avgAmplitude,amplitudes};}).filter(item=>item.avgAmplitude!==-999);if(fileAmplitudes.length===0)continue;// Find min and max average amplitudes in this band\nconst avgAmps=fileAmplitudes.map(item=>item.avgAmplitude);const minAvgAmp=Math.min(...avgAmps);const maxAvgAmp=Math.max(...avgAmps);const ampRange=maxAvgAmp-minAvgAmp;console.log(\"\\uD83D\\uDCCA Band \".concat(band,\" amplitude range: \").concat(minAvgAmp.toFixed(1),\" to \").concat(maxAvgAmp.toFixed(1),\" dB (range: \").concat(ampRange.toFixed(1),\" dB)\"));// Calculate relative noisiness for each file in this band\nfor(const{file,avgAmplitude,amplitudes}of fileAmplitudes){// Calculate relative position within band (0-1)\nlet relativePosition=0;if(ampRange>0.1){// Avoid division by very small numbers\nrelativePosition=(avgAmplitude-minAvgAmp)/ampRange;}else{// If all files have very similar amplitudes, give them middle scores\nrelativePosition=0.5;}// Scale to 1-10 range with clear distinctions\n// Quietest file gets 1, noisiest gets 10\nconst bandRelativeNoisiness=Math.round(relativePosition*9+1);// Calculate other metrics for completeness (but don't use them much)\nconst varianceScore=this.calculateVarianceScore(amplitudes);const peakToRmsRatio=this.calculatePeakToRmsRatio(amplitudes);const spectralFlatness=this.calculateSpectralFlatness(amplitudes);const highFreqContent=this.calculateHighFrequencyContent(file.data);const smallPeakDensity=this.calculateSmallPeakDensity(amplitudes);const result={filename:file.filename,noisinessIndex:bandRelativeNoisiness,metrics:{averageAmplitude:relativePosition,// Store relative position\nvarianceScore,peakToRmsRatio,spectralFlatness,highFreqContent,smallPeakDensity,overallNoisiness:bandRelativeNoisiness},confidence:amplitudes.length>=100?'high':amplitudes.length>=50?'medium':'low',category:this.categorizeNoisiness(bandRelativeNoisiness)};allResults.push(result);console.log(\"\\uD83D\\uDCC8 \".concat(file.filename,\": Avg=\").concat(avgAmplitude.toFixed(1),\"dB, Relative=\").concat(relativePosition.toFixed(2),\", Noisiness=\").concat(bandRelativeNoisiness,\"/10\"));}}console.log(\"\\u2705 Band-relative noisiness analysis complete for \".concat(filesData.length,\" files\"));console.log(\"\\uD83D\\uDCCA Results: Files now ranked 1-10 within their respective bands (1=quietest, 10=noisiest)\");return allResults;}}","map":{"version":3,"names":["NoiseAnalysisService","calculateNoisinessIndex","data","filename","arguments","length","undefined","amplitudes","map","point","amplitude","filter","amp","isFinite","averageAmplitude","calculateAverageAmplitudeScore","fallbackScore","Math","round","noisinessIndex","metrics","varianceScore","peakToRmsRatio","spectralFlatness","highFreqContent","smallPeakDensity","overallNoisiness","confidence","category","frequencies","frequency","freq","simpleVariance","calculateSimpleNoisiness","combinedScore","finalScore","categorizeNoisiness","calculateVarianceScore","calculatePeakToRmsRatio","calculateSpectralFlatness","calculateHighFrequencyContent","calculateSmallPeakDensity","signalSmoothness","calculateSignalSmoothness","dynamicRange","calculateDynamicRange","combineEnhancedMetrics","finalNoisiness","max","min","assessConfidence","validAmplitudes","reduce","sum","val","minExpectedAmplitude","maxExpectedAmplitude","normalizedAmplitude","clampedNormalized","sigmoidInput","sigmoidOutput","exp","calculateAdaptiveThreshold","sorted","sort","a","b","q1","floor","q3","iqr","totalVariation","i","secondDerivative","abs","avgVariation","range","normalizedRange","averageAmplitudeScore","mean","variance","pow","stdDev","sqrt","normalizedStdDev","varianceNormalized","adaptiveThreshold","score","peak","rms","crestFactor","skewness","calculateSkewness","crestScore","skewnessScore","linearAmplitudes","linear","logSum","logVal","log","geometricMean","arithmeticMean","flatness","validData","sortedByFreq","totalRange","highFreqThreshold","highFreqPoints","lowFreqPoints","highFreqMean","p","lowFreqMean","ratio","peakCount","threshold","current","leftAvg","rightAvg","density","weights","safeAverageAmplitude","safeVariance","safePeakRms","safeFlatness","safeHighFreq","safePeakDensity","safeSmoothness","safeDynamicRange","weightedSum","result","dataLength","freqRange","noisiness","getNoisinessColor","getNoisinessEmoji","getNoisinessDescription","batchAnalyzeAndRank","files","results","file","calculateBandRelativeNoisiness","filesData","filesByBand","groups","band","push","allResults","bandFiles","Object","entries","console","concat","fileAmplitudes","avgAmplitude","item","avgAmps","minAvgAmp","maxAvgAmp","ampRange","toFixed","relativePosition","bandRelativeNoisiness"],"sources":["/Users/howardwang/Desktop/Turner Engineering/Software Product Design/reda-main/typescript-react-app/src/services/NoiseAnalysisService.ts"],"sourcesContent":["// ========================================================================\n// REDA EMC Testing Tool - Noise Analysis Service\n// ========================================================================\n// Turner Engineering Corporation - Professional EMC Testing Support\n// \n// Service for analyzing signal noisiness and calculating noisiness indices\n// ========================================================================\n\nimport { CsvDataPoint } from '../types';\n\n// ========================================================================\n// NOISE ANALYSIS INTERFACES\n// ========================================================================\n\nexport interface NoisinessMetrics {\n  averageAmplitude: number;    // 0-1, higher = higher average amplitude (primary noisiness indicator)\n  varianceScore: number;       // 0-1, higher = more variance/noise\n  peakToRmsRatio: number;      // Lower values indicate more noise\n  spectralFlatness: number;    // 0-1, higher = flatter spectrum (more noise)\n  highFreqContent: number;     // 0-1, higher = more high-freq noise\n  smallPeakDensity: number;    // 0-1, higher = more noise spikes\n  overallNoisiness: number;    // 0-100, final noisiness index\n}\n\nexport interface NoiseAnalysisResult {\n  filename: string;\n  noisinessIndex: number;      // 0-100 scale\n  metrics: NoisinessMetrics;\n  confidence: 'high' | 'medium' | 'low';\n  category: 'very_quiet' | 'quiet' | 'moderate' | 'noisy' | 'very_noisy';\n}\n\n// ========================================================================\n// NOISE ANALYSIS SERVICE\n// ========================================================================\n\nexport class NoiseAnalysisService {\n  \n  /**\n   * Calculate comprehensive noisiness index for signal data\n   */\n  static calculateNoisinessIndex(\n    data: CsvDataPoint[], \n    filename: string = 'unknown'\n  ): NoiseAnalysisResult {\n    \n    if (!data || data.length < 10) {\n      // Calculate average amplitude even with limited data if possible\n      const amplitudes = data?.map(point => point.amplitude).filter(amp => isFinite(amp)) || [];\n      const averageAmplitude = amplitudes.length > 0 ? this.calculateAverageAmplitudeScore(amplitudes) : 0;\n      const fallbackScore = amplitudes.length > 0 ? Math.round(averageAmplitude * 95 + 5) : 50; // 95% average amplitude, 5% base\n      \n      return {\n        filename,\n        noisinessIndex: fallbackScore,\n        metrics: {\n          averageAmplitude,\n          varianceScore: 0,\n          peakToRmsRatio: 0,\n          spectralFlatness: 0,\n          highFreqContent: 0,\n          smallPeakDensity: 0,\n          overallNoisiness: fallbackScore\n        },\n        confidence: 'low',\n        category: 'moderate'\n      };\n    }\n\n    const amplitudes = data.map(point => point.amplitude).filter(amp => isFinite(amp));\n    const frequencies = data.map(point => point.frequency).filter(freq => isFinite(freq));\n    \n    // Early validation - if we don't have enough valid data, use simplified calculation\n    if (amplitudes.length < 10) {\n      const averageAmplitude = this.calculateAverageAmplitudeScore(amplitudes);\n      const simpleVariance = this.calculateSimpleNoisiness(amplitudes);\n      \n      // Almost entirely based on average amplitude (95%) with minimal variance (5%)\n      const combinedScore = averageAmplitude * 0.95 + (simpleVariance / 100) * 0.05;\n      const finalScore = Math.round(combinedScore * 100);\n      \n      return {\n        filename,\n        noisinessIndex: finalScore,\n        metrics: {\n          averageAmplitude,\n          varianceScore: simpleVariance / 100,\n          peakToRmsRatio: 0.5,\n          spectralFlatness: 0.5,\n          highFreqContent: 0.5,\n          smallPeakDensity: 0.5,\n          overallNoisiness: finalScore\n        },\n        confidence: 'low',\n        category: this.categorizeNoisiness(finalScore)\n      };\n    }\n    \n    // Calculate enhanced metrics for better discrimination\n    const averageAmplitude = this.calculateAverageAmplitudeScore(amplitudes);\n    const varianceScore = this.calculateVarianceScore(amplitudes);\n    const peakToRmsRatio = this.calculatePeakToRmsRatio(amplitudes);\n    const spectralFlatness = this.calculateSpectralFlatness(amplitudes);\n    const highFreqContent = this.calculateHighFrequencyContent(data);\n    const smallPeakDensity = this.calculateSmallPeakDensity(amplitudes);\n    \n    // Additional discriminating metrics\n    const signalSmoothness = this.calculateSignalSmoothness(amplitudes);\n    const dynamicRange = this.calculateDynamicRange(amplitudes);\n    \n    // Enhanced weighted combination prioritizing average amplitude for noisiness\n    const overallNoisiness = this.combineEnhancedMetrics({\n      averageAmplitude,\n      varianceScore,\n      peakToRmsRatio,\n      spectralFlatness,\n      highFreqContent,\n      smallPeakDensity,\n      signalSmoothness,\n      dynamicRange\n    });\n\n    const metrics: NoisinessMetrics = {\n      averageAmplitude,\n      varianceScore,\n      peakToRmsRatio,\n      spectralFlatness,\n      highFreqContent,\n      smallPeakDensity,\n      overallNoisiness\n    };\n\n    // Ensure the final noisiness index is finite and within bounds\n    const finalNoisiness = isFinite(overallNoisiness) ? Math.round(Math.max(0, Math.min(100, overallNoisiness))) : 50;\n\n    return {\n      filename,\n      noisinessIndex: finalNoisiness,\n      metrics,\n      confidence: this.assessConfidence(data.length, frequencies),\n      category: this.categorizeNoisiness(finalNoisiness)\n    };\n  }\n\n  /**\n   * Calculate average amplitude score (0-1, higher = higher average amplitude = noisier)\n   * This is the primary metric for determining noisiness based on average amplitude values\n   */\n  private static calculateAverageAmplitudeScore(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 0;\n    \n    // Filter out any non-finite values\n    const validAmplitudes = amplitudes.filter(amp => isFinite(amp));\n    if (validAmplitudes.length === 0) return 0;\n    \n    // Calculate simple average amplitude\n    const averageAmplitude = validAmplitudes.reduce((sum, val) => sum + val, 0) / validAmplitudes.length;\n    \n    if (!isFinite(averageAmplitude)) return 0;\n    \n    // Normalize average amplitude to 0-1 scale\n    // EMC data typically ranges from very low (quiet) to high (noisy) amplitudes\n    // We use a sigmoid function to map average amplitude to noisiness score\n    // Assume amplitudes typically range from -80dB to +20dB, with higher values being noisier\n    const minExpectedAmplitude = -80; // dB - very quiet signal\n    const maxExpectedAmplitude = 20;  // dB - very noisy signal\n    \n    // Normalize to 0-1 range\n    const normalizedAmplitude = (averageAmplitude - minExpectedAmplitude) / (maxExpectedAmplitude - minExpectedAmplitude);\n    \n    // Apply sigmoid transformation for smooth transition\n    // Values closer to maxExpectedAmplitude will be closer to 1 (noisier)\n    const clampedNormalized = Math.max(0, Math.min(1, normalizedAmplitude));\n    \n    // Use a sigmoid to enhance the separation between different amplitude levels\n    const sigmoidInput = (clampedNormalized - 0.5) * 6; // Scale for steeper curve\n    const sigmoidOutput = 1 / (1 + Math.exp(-sigmoidInput));\n    \n    return isFinite(sigmoidOutput) ? sigmoidOutput : 0.5;\n  }\n\n  /**\n   * Calculate adaptive threshold based on signal characteristics\n   */\n  private static calculateAdaptiveThreshold(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 10;\n    \n    const sorted = [...amplitudes].sort((a, b) => a - b);\n    const q1 = sorted[Math.floor(amplitudes.length * 0.25)];\n    const q3 = sorted[Math.floor(amplitudes.length * 0.75)];\n    const iqr = q3 - q1;\n    \n    // Adaptive threshold based on interquartile range\n    // Clean signals typically have small IQR, noisy signals have large IQR\n    return Math.max(3, Math.min(25, iqr * 2 + 5));\n  }\n\n  /**\n   * Enhanced signal smoothness analysis\n   */\n  private static calculateSignalSmoothness(amplitudes: number[]): number {\n    if (amplitudes.length < 3) return 0;\n    \n    let totalVariation = 0;\n    for (let i = 1; i < amplitudes.length - 1; i++) {\n      // Second derivative approximation (measure of \"jaggedness\")\n      const secondDerivative = amplitudes[i+1] - 2*amplitudes[i] + amplitudes[i-1];\n      totalVariation += Math.abs(secondDerivative);\n    }\n    \n    const avgVariation = totalVariation / (amplitudes.length - 2);\n    // Sigmoid transformation for better separation\n    return 1 / (1 + Math.exp(-0.5 * (avgVariation - 3)));\n  }\n\n  /**\n   * Dynamic range analysis\n   */\n  private static calculateDynamicRange(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 0;\n    \n    const sorted = [...amplitudes].sort((a, b) => a - b);\n    const min = sorted[0];\n    const max = sorted[sorted.length - 1];\n    const range = max - min;\n    \n    // Very clean signals often have consistent levels (low range)\n    // Very noisy signals have extreme variations (high range)\n    const normalizedRange = Math.min(range / 50, 1); // Assume 50dB max reasonable range\n    return normalizedRange;\n  }\n\n  /**\n   * Simple noisiness calculation for cases with limited data\n   * Now almost entirely based on average amplitude (95%)\n   */\n  private static calculateSimpleNoisiness(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 50;\n    \n    // Calculate average amplitude score (dominant factor)\n    const averageAmplitudeScore = this.calculateAverageAmplitudeScore(amplitudes);\n    \n    // Simple standard deviation based calculation (minimal factor)\n    const mean = amplitudes.reduce((sum, val) => sum + val, 0) / amplitudes.length;\n    const variance = amplitudes.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / amplitudes.length;\n    const stdDev = Math.sqrt(variance);\n    \n    // Enhanced scaling with sigmoid for better separation\n    const normalizedStdDev = stdDev / 8; // Adaptive to typical EMC data\n    const varianceScore = 100 / (1 + Math.exp(-2 * (normalizedStdDev - 1)));\n    const varianceNormalized = Math.max(5, Math.min(95, varianceScore)) / 100;\n    \n    // Almost entirely based on average amplitude (95%) with minimal variance (5%)\n    const combinedScore = averageAmplitudeScore * 0.95 + varianceNormalized * 0.05;\n    const finalScore = Math.round(combinedScore * 100);\n    \n    return Math.max(5, Math.min(95, finalScore));\n  }\n\n  /**\n   * Calculate variance-based noise score with adaptive scaling\n   */\n  private static calculateVarianceScore(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 0;\n    \n    // Filter out any non-finite values\n    const validAmplitudes = amplitudes.filter(amp => isFinite(amp));\n    if (validAmplitudes.length === 0) return 0;\n    \n    const mean = validAmplitudes.reduce((sum, val) => sum + val, 0) / validAmplitudes.length;\n    const variance = validAmplitudes.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / validAmplitudes.length;\n    const stdDev = Math.sqrt(variance);\n    \n    // Enhanced adaptive scaling based on signal characteristics\n    // Use sigmoid function for better separation\n    const adaptiveThreshold = this.calculateAdaptiveThreshold(validAmplitudes);\n    const normalizedStdDev = stdDev / adaptiveThreshold;\n    \n    // Sigmoid transformation for better dynamic range (0-1)\n    const score = 1 / (1 + Math.exp(-3 * (normalizedStdDev - 1)));\n    return isFinite(score) ? score : 0;\n  }\n\n  /**\n   * Enhanced peak-to-RMS analysis with crest factor and distribution analysis\n   */\n  private static calculatePeakToRmsRatio(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 0;\n    \n    // Filter out any non-finite values\n    const validAmplitudes = amplitudes.filter(amp => isFinite(amp));\n    if (validAmplitudes.length === 0) return 0;\n    \n    const peak = Math.max(...validAmplitudes);\n    const rms = Math.sqrt(validAmplitudes.reduce((sum, val) => sum + val * val, 0) / validAmplitudes.length);\n    \n    if (!isFinite(peak) || !isFinite(rms) || rms === 0) return 0;\n    \n    const crestFactor = peak / rms;\n    if (!isFinite(crestFactor)) return 0;\n    \n    // Enhanced analysis: combine crest factor with distribution characteristics\n    const mean = validAmplitudes.reduce((sum, val) => sum + val, 0) / validAmplitudes.length;\n    const skewness = this.calculateSkewness(validAmplitudes, mean);\n    \n    // Clean signals: high crest factor + low skewness\n    // Noisy signals: low crest factor + high skewness\n    const crestScore = 1 / (1 + Math.exp(-0.5 * (crestFactor - 4))); // Sigmoid around crest factor of 4\n    const skewnessScore = Math.abs(skewness) / 3; // Normalize skewness influence\n    \n    // Combined score (inverted because lower = more noise for final calculation)\n    const combinedScore = (crestScore * 0.7 + (1 - skewnessScore) * 0.3);\n    return Math.max(0, Math.min(1, combinedScore));\n  }\n\n  /**\n   * Calculate skewness of amplitude distribution\n   */\n  private static calculateSkewness(amplitudes: number[], mean: number): number {\n    if (amplitudes.length === 0) return 0;\n    \n    const variance = amplitudes.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / amplitudes.length;\n    const stdDev = Math.sqrt(variance);\n    \n    if (stdDev === 0) return 0;\n    \n    const skewness = amplitudes.reduce((sum, val) => sum + Math.pow((val - mean) / stdDev, 3), 0) / amplitudes.length;\n    return isFinite(skewness) ? skewness : 0;\n  }\n\n  /**\n   * Calculate spectral flatness (0-1, higher = flatter/noisier)\n   */\n  private static calculateSpectralFlatness(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 0;\n    \n    // Convert to linear scale for calculation, ensuring no zero values\n    const linearAmplitudes = amplitudes.map(amp => {\n      const linear = Math.pow(10, amp / 20);\n      return Math.max(linear, 1e-12); // Prevent zero values\n    });\n    \n    // Calculate geometric mean using log-space to avoid overflow/underflow\n    const logSum = linearAmplitudes.reduce((sum, val) => {\n      const logVal = Math.log(val);\n      return sum + (isFinite(logVal) ? logVal : -27.6); // log(1e-12) â‰ˆ -27.6\n    }, 0);\n    const geometricMean = Math.exp(logSum / linearAmplitudes.length);\n    \n    // Arithmetic mean\n    const arithmeticMean = linearAmplitudes.reduce((sum, val) => sum + val, 0) / linearAmplitudes.length;\n    \n    // Ensure we don't divide by zero and result is finite\n    if (!isFinite(geometricMean) || !isFinite(arithmeticMean) || arithmeticMean === 0) {\n      return 0;\n    }\n    \n    const flatness = geometricMean / arithmeticMean;\n    return isFinite(flatness) ? Math.min(flatness, 1) : 0;\n  }\n\n  /**\n   * Calculate high-frequency content ratio\n   */\n  private static calculateHighFrequencyContent(data: CsvDataPoint[]): number {\n    if (data.length < 4) return 0;\n    \n    // Filter out any points with non-finite values\n    const validData = data.filter(point => \n      isFinite(point.frequency) && isFinite(point.amplitude)\n    );\n    \n    if (validData.length < 4) return 0;\n    \n    const sortedByFreq = [...validData].sort((a, b) => a.frequency - b.frequency);\n    const totalRange = sortedByFreq[sortedByFreq.length - 1].frequency - sortedByFreq[0].frequency;\n    \n    if (totalRange === 0 || !isFinite(totalRange)) return 0;\n    \n    // Define \"high frequency\" as top 25% of the frequency range\n    const highFreqThreshold = sortedByFreq[0].frequency + totalRange * 0.75;\n    \n    const highFreqPoints = validData.filter(point => point.frequency >= highFreqThreshold);\n    const lowFreqPoints = validData.filter(point => point.frequency < highFreqThreshold);\n    \n    if (lowFreqPoints.length === 0 || highFreqPoints.length === 0) return 0;\n    \n    const highFreqMean = highFreqPoints.reduce((sum, p) => sum + p.amplitude, 0) / highFreqPoints.length;\n    const lowFreqMean = lowFreqPoints.reduce((sum, p) => sum + p.amplitude, 0) / lowFreqPoints.length;\n    \n    if (!isFinite(highFreqMean) || !isFinite(lowFreqMean) || lowFreqMean === 0) return 0;\n    \n    // High frequency content relative to low frequency content\n    const ratio = highFreqMean / lowFreqMean;\n    \n    if (!isFinite(ratio)) return 0;\n    \n    // Normalize to 0-1 scale - higher ratio suggests more high-freq noise\n    const score = Math.min(Math.max(0, (ratio - 0.5) / 1.5), 1);\n    return isFinite(score) ? score : 0;\n  }\n\n  /**\n   * Calculate density of small peaks (noise spikes)\n   */\n  private static calculateSmallPeakDensity(amplitudes: number[]): number {\n    if (amplitudes.length < 5) return 0;\n    \n    // Filter out any non-finite values\n    const validAmplitudes = amplitudes.filter(amp => isFinite(amp));\n    if (validAmplitudes.length < 5) return 0;\n    \n    let peakCount = 0;\n    const threshold = 2; // dB threshold for considering a peak\n    \n    for (let i = 2; i < validAmplitudes.length - 2; i++) {\n      const current = validAmplitudes[i];\n      const leftAvg = (validAmplitudes[i-1] + validAmplitudes[i-2]) / 2;\n      const rightAvg = (validAmplitudes[i+1] + validAmplitudes[i+2]) / 2;\n      \n      // Ensure all values are finite\n      if (!isFinite(current) || !isFinite(leftAvg) || !isFinite(rightAvg)) continue;\n      \n      // Check if current point is a local peak above threshold\n      if (current > leftAvg + threshold && current > rightAvg + threshold) {\n        peakCount++;\n      }\n    }\n    \n    // Density of peaks per 100 data points\n    const density = (peakCount / validAmplitudes.length) * 100;\n    \n    if (!isFinite(density)) return 0;\n    \n    // Normalize to 0-1 scale - more peaks suggest more noise\n    const score = Math.min(density / 10, 1); // Assume 10 peaks per 100 points = very noisy\n    return isFinite(score) ? score : 0;\n  }\n\n  /**\n   * Enhanced metric combination with better discrimination\n   */\n  private static combineEnhancedMetrics(metrics: {\n    averageAmplitude: number;\n    varianceScore: number;\n    peakToRmsRatio: number;\n    spectralFlatness: number;\n    highFreqContent: number;\n    smallPeakDensity: number;\n    signalSmoothness: number;\n    dynamicRange: number;\n  }): number {\n    // Simplified weighting - average amplitude is now the dominant factor\n    const weights = {\n      averageAmplitude: 0.95,      // 95% - average amplitude (DOMINANT factor)\n      varianceScore: 0.02,         // 2% - minimal variance influence\n      peakToRmsRatio: 0.01,        // 1% - minimal peak ratio influence\n      spectralFlatness: 0.01,      // 1% - minimal spectral influence\n      highFreqContent: 0.005,      // 0.5% - minimal high-freq influence\n      smallPeakDensity: 0.005,     // 0.5% - minimal peak density influence\n      signalSmoothness: 0.0,       // 0% - disabled\n      dynamicRange: 0.0            // 0% - disabled\n    };\n    \n    // Ensure all metric values are finite before combining\n    const safeAverageAmplitude = isFinite(metrics.averageAmplitude) ? metrics.averageAmplitude : 0.5;\n    const safeVariance = isFinite(metrics.varianceScore) ? metrics.varianceScore : 0.5;\n    const safePeakRms = isFinite(metrics.peakToRmsRatio) ? metrics.peakToRmsRatio : 0.5;\n    const safeFlatness = isFinite(metrics.spectralFlatness) ? metrics.spectralFlatness : 0.5;\n    const safeHighFreq = isFinite(metrics.highFreqContent) ? metrics.highFreqContent : 0.5;\n    const safePeakDensity = isFinite(metrics.smallPeakDensity) ? metrics.smallPeakDensity : 0.5;\n    const safeSmoothness = isFinite(metrics.signalSmoothness) ? metrics.signalSmoothness : 0.5;\n    const safeDynamicRange = isFinite(metrics.dynamicRange) ? metrics.dynamicRange : 0.5;\n    \n    const weightedSum = \n      safeAverageAmplitude * weights.averageAmplitude +\n      safeVariance * weights.varianceScore +\n      safePeakRms * weights.peakToRmsRatio +\n      safeFlatness * weights.spectralFlatness +\n      safeHighFreq * weights.highFreqContent +\n      safePeakDensity * weights.smallPeakDensity +\n      safeSmoothness * weights.signalSmoothness +\n      safeDynamicRange * weights.dynamicRange;\n    \n    // Apply final sigmoid transformation for enhanced separation\n    // This spreads out the middle values more effectively\n    const sigmoidInput = (weightedSum - 0.5) * 4; // Scale and center around 0\n    const sigmoidOutput = 1 / (1 + Math.exp(-sigmoidInput));\n    \n    // Convert to 0-100 scale with enhanced dynamic range\n    const result = sigmoidOutput * 100;\n    return isFinite(result) ? Math.max(1, Math.min(99, result)) : 50;\n  }\n\n  /**\n   * Assess confidence in the noisiness calculation\n   */\n  private static assessConfidence(\n    dataLength: number, \n    frequencies: number[]\n  ): 'high' | 'medium' | 'low' {\n    const freqRange = Math.max(...frequencies) - Math.min(...frequencies);\n    \n    if (dataLength >= 1000 && freqRange > 0) return 'high';\n    if (dataLength >= 100 && freqRange > 0) return 'medium';\n    return 'low';\n  }\n\n  /**\n   * Categorize noisiness level for 1-10 scale\n   */\n  private static categorizeNoisiness(noisiness: number): NoiseAnalysisResult['category'] {\n    if (noisiness <= 2) return 'very_quiet';\n    if (noisiness <= 4) return 'quiet';\n    if (noisiness <= 6) return 'moderate';\n    if (noisiness <= 8) return 'noisy';\n    return 'very_noisy';\n  }\n\n  /**\n   * Get color for noisiness visualization (1-10 scale)\n   */\n  static getNoisinessColor(noisiness: number): string {\n    if (noisiness <= 2) return '#2ecc71'; // Green - very quiet\n    if (noisiness <= 4) return '#27ae60'; // Dark green - quiet  \n    if (noisiness <= 6) return '#f39c12'; // Orange - moderate\n    if (noisiness <= 8) return '#e67e22'; // Dark orange - noisy\n    return '#e74c3c'; // Red - very noisy\n  }\n\n  /**\n   * Get emoji for noisiness level (1-10 scale)\n   */\n  static getNoisinessEmoji(noisiness: number): string {\n    if (noisiness <= 2) return 'ðŸ”‡'; // Very quiet\n    if (noisiness <= 4) return 'ðŸ”‰'; // Quiet\n    if (noisiness <= 6) return 'ðŸ”Š'; // Moderate\n    if (noisiness <= 8) return 'ðŸ“¢'; // Noisy\n    return 'ðŸš¨'; // Very noisy\n  }\n\n  /**\n   * Get text description for noisiness level (1-10 scale)\n   */\n  static getNoisinessDescription(noisiness: number): string {\n    if (noisiness <= 2) return 'Very Quiet';\n    if (noisiness <= 4) return 'Quiet';\n    if (noisiness <= 6) return 'Moderate';\n    if (noisiness <= 8) return 'Noisy';\n    return 'Very Noisy';\n  }\n\n  /**\n   * Batch analyze multiple files and rank by noisiness\n   */\n  static async batchAnalyzeAndRank(\n    files: Array<{ filename: string; data: CsvDataPoint[] }>\n  ): Promise<NoiseAnalysisResult[]> {\n    const results = files.map(file => \n      this.calculateNoisinessIndex(file.data, file.filename)\n    );\n    \n    // Sort by noisiness (highest first)\n    return results.sort((a, b) => b.noisinessIndex - a.noisinessIndex);\n  }\n\n  /**\n   * Calculate band-relative noisiness index for multiple files in the same band\n   * This method compares files within their band and scales from 0-100\n   * @param filesData Array of files with their data and band information\n   * @returns Array of results with relative noisiness (0-100 within band)\n   */\n  static calculateBandRelativeNoisiness(\n    filesData: Array<{ filename: string; data: CsvDataPoint[]; band?: string }>\n  ): NoiseAnalysisResult[] {\n    if (filesData.length === 0) return [];\n    \n    // Group files by band\n    const filesByBand = filesData.reduce((groups, file) => {\n      const band = file.band || 'Unknown';\n      if (!groups[band]) groups[band] = [];\n      groups[band].push(file);\n      return groups;\n    }, {} as Record<string, typeof filesData>);\n    \n    const allResults: NoiseAnalysisResult[] = [];\n    \n    // Process each band separately\n    for (const [band, bandFiles] of Object.entries(filesByBand)) {\n      console.log(`ðŸŽ¯ Processing ${bandFiles.length} files in band ${band}`);\n      \n      // Calculate average amplitude for each file in this band\n      const fileAmplitudes = bandFiles.map(file => {\n        const amplitudes = file.data.map(point => point.amplitude).filter(amp => isFinite(amp));\n        const avgAmplitude = amplitudes.length > 0 \n          ? amplitudes.reduce((sum, val) => sum + val, 0) / amplitudes.length\n          : -999;\n        return { file, avgAmplitude, amplitudes };\n      }).filter(item => item.avgAmplitude !== -999);\n      \n      if (fileAmplitudes.length === 0) continue;\n      \n      // Find min and max average amplitudes in this band\n      const avgAmps = fileAmplitudes.map(item => item.avgAmplitude);\n      const minAvgAmp = Math.min(...avgAmps);\n      const maxAvgAmp = Math.max(...avgAmps);\n      const ampRange = maxAvgAmp - minAvgAmp;\n      \n      console.log(`ðŸ“Š Band ${band} amplitude range: ${minAvgAmp.toFixed(1)} to ${maxAvgAmp.toFixed(1)} dB (range: ${ampRange.toFixed(1)} dB)`);\n      \n      // Calculate relative noisiness for each file in this band\n      for (const { file, avgAmplitude, amplitudes } of fileAmplitudes) {\n        // Calculate relative position within band (0-1)\n        let relativePosition = 0;\n        if (ampRange > 0.1) { // Avoid division by very small numbers\n          relativePosition = (avgAmplitude - minAvgAmp) / ampRange;\n        } else {\n          // If all files have very similar amplitudes, give them middle scores\n          relativePosition = 0.5;\n        }\n        \n        // Scale to 1-10 range with clear distinctions\n        // Quietest file gets 1, noisiest gets 10\n        const bandRelativeNoisiness = Math.round(relativePosition * 9 + 1);\n        \n        // Calculate other metrics for completeness (but don't use them much)\n        const varianceScore = this.calculateVarianceScore(amplitudes);\n        const peakToRmsRatio = this.calculatePeakToRmsRatio(amplitudes);\n        const spectralFlatness = this.calculateSpectralFlatness(amplitudes);\n        const highFreqContent = this.calculateHighFrequencyContent(file.data);\n        const smallPeakDensity = this.calculateSmallPeakDensity(amplitudes);\n        \n        const result: NoiseAnalysisResult = {\n          filename: file.filename,\n          noisinessIndex: bandRelativeNoisiness,\n          metrics: {\n            averageAmplitude: relativePosition, // Store relative position\n            varianceScore,\n            peakToRmsRatio,\n            spectralFlatness,\n            highFreqContent,\n            smallPeakDensity,\n            overallNoisiness: bandRelativeNoisiness\n          },\n          confidence: amplitudes.length >= 100 ? 'high' : amplitudes.length >= 50 ? 'medium' : 'low',\n          category: this.categorizeNoisiness(bandRelativeNoisiness)\n        };\n        \n        allResults.push(result);\n        console.log(`ðŸ“ˆ ${file.filename}: Avg=${avgAmplitude.toFixed(1)}dB, Relative=${relativePosition.toFixed(2)}, Noisiness=${bandRelativeNoisiness}/10`);\n      }\n    }\n    \n    console.log(`âœ… Band-relative noisiness analysis complete for ${filesData.length} files`);\n    console.log(`ðŸ“Š Results: Files now ranked 1-10 within their respective bands (1=quietest, 10=noisiest)`);\n    \n    return allResults;\n  }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}