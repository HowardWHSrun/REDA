{"ast":null,"code":"// ========================================================================\n// REDA EMC Testing Tool - Noise Analysis Service\n// ========================================================================\n// Turner Engineering Corporation - Professional EMC Testing Support\n// \n// Service for analyzing signal noisiness and calculating noisiness indices\n// ========================================================================\n\n// ========================================================================\n// NOISE ANALYSIS INTERFACES\n// ========================================================================\n\n// ========================================================================\n// NOISE ANALYSIS SERVICE\n// ========================================================================\n\nexport class NoiseAnalysisService {\n  /**\n   * Calculate comprehensive noisiness index for signal data\n   */\n  static calculateNoisinessIndex(data, filename = 'unknown') {\n    if (!data || data.length < 10) {\n      // Calculate average amplitude even with limited data if possible\n      const amplitudes = (data === null || data === void 0 ? void 0 : data.map(point => point.amplitude).filter(amp => isFinite(amp))) || [];\n      const averageAmplitude = amplitudes.length > 0 ? this.calculateAverageAmplitudeScore(amplitudes) : 0;\n      const fallbackScore = amplitudes.length > 0 ? Math.round(averageAmplitude * 95 + 5) : 50; // 95% average amplitude, 5% base\n\n      return {\n        filename,\n        noisinessIndex: fallbackScore,\n        metrics: {\n          averageAmplitude,\n          varianceScore: 0,\n          peakToRmsRatio: 0,\n          spectralFlatness: 0,\n          highFreqContent: 0,\n          smallPeakDensity: 0,\n          overallNoisiness: fallbackScore\n        },\n        confidence: 'low',\n        category: 'moderate'\n      };\n    }\n    const amplitudes = data.map(point => point.amplitude).filter(amp => isFinite(amp));\n    const frequencies = data.map(point => point.frequency).filter(freq => isFinite(freq));\n\n    // Early validation - if we don't have enough valid data, use simplified calculation\n    if (amplitudes.length < 10) {\n      const averageAmplitude = this.calculateAverageAmplitudeScore(amplitudes);\n      const simpleVariance = this.calculateSimpleNoisiness(amplitudes);\n\n      // Almost entirely based on average amplitude (95%) with minimal variance (5%)\n      const combinedScore = averageAmplitude * 0.95 + simpleVariance / 100 * 0.05;\n      const finalScore = Math.round(combinedScore * 100);\n      return {\n        filename,\n        noisinessIndex: finalScore,\n        metrics: {\n          averageAmplitude,\n          varianceScore: simpleVariance / 100,\n          peakToRmsRatio: 0.5,\n          spectralFlatness: 0.5,\n          highFreqContent: 0.5,\n          smallPeakDensity: 0.5,\n          overallNoisiness: finalScore\n        },\n        confidence: 'low',\n        category: this.categorizeNoisiness(finalScore)\n      };\n    }\n\n    // Calculate enhanced metrics for better discrimination\n    const averageAmplitude = this.calculateAverageAmplitudeScore(amplitudes);\n    const varianceScore = this.calculateVarianceScore(amplitudes);\n    const peakToRmsRatio = this.calculatePeakToRmsRatio(amplitudes);\n    const spectralFlatness = this.calculateSpectralFlatness(amplitudes);\n    const highFreqContent = this.calculateHighFrequencyContent(data);\n    const smallPeakDensity = this.calculateSmallPeakDensity(amplitudes);\n\n    // Additional discriminating metrics\n    const signalSmoothness = this.calculateSignalSmoothness(amplitudes);\n    const dynamicRange = this.calculateDynamicRange(amplitudes);\n\n    // Enhanced weighted combination prioritizing average amplitude for noisiness\n    const overallNoisiness = this.combineEnhancedMetrics({\n      averageAmplitude,\n      varianceScore,\n      peakToRmsRatio,\n      spectralFlatness,\n      highFreqContent,\n      smallPeakDensity,\n      signalSmoothness,\n      dynamicRange\n    });\n    const metrics = {\n      averageAmplitude,\n      varianceScore,\n      peakToRmsRatio,\n      spectralFlatness,\n      highFreqContent,\n      smallPeakDensity,\n      overallNoisiness\n    };\n\n    // Ensure the final noisiness index is finite and within bounds\n    const finalNoisiness = isFinite(overallNoisiness) ? Math.round(Math.max(0, Math.min(100, overallNoisiness))) : 50;\n    return {\n      filename,\n      noisinessIndex: finalNoisiness,\n      metrics,\n      confidence: this.assessConfidence(data.length, frequencies),\n      category: this.categorizeNoisiness(finalNoisiness)\n    };\n  }\n\n  /**\n   * Calculate average amplitude score (0-1, higher = higher average amplitude = noisier)\n   * This is the primary metric for determining noisiness based on average amplitude values\n   */\n  static calculateAverageAmplitudeScore(amplitudes) {\n    if (amplitudes.length === 0) return 0;\n\n    // Filter out any non-finite values\n    const validAmplitudes = amplitudes.filter(amp => isFinite(amp));\n    if (validAmplitudes.length === 0) return 0;\n\n    // Calculate simple average amplitude\n    const averageAmplitude = validAmplitudes.reduce((sum, val) => sum + val, 0) / validAmplitudes.length;\n    if (!isFinite(averageAmplitude)) return 0;\n\n    // Normalize average amplitude to 0-1 scale\n    // EMC data typically ranges from very low (quiet) to high (noisy) amplitudes\n    // We use a sigmoid function to map average amplitude to noisiness score\n    // Assume amplitudes typically range from -80dB to +20dB, with higher values being noisier\n    const minExpectedAmplitude = -80; // dB - very quiet signal\n    const maxExpectedAmplitude = 20; // dB - very noisy signal\n\n    // Normalize to 0-1 range\n    const normalizedAmplitude = (averageAmplitude - minExpectedAmplitude) / (maxExpectedAmplitude - minExpectedAmplitude);\n\n    // Apply sigmoid transformation for smooth transition\n    // Values closer to maxExpectedAmplitude will be closer to 1 (noisier)\n    const clampedNormalized = Math.max(0, Math.min(1, normalizedAmplitude));\n\n    // Use a sigmoid to enhance the separation between different amplitude levels\n    const sigmoidInput = (clampedNormalized - 0.5) * 6; // Scale for steeper curve\n    const sigmoidOutput = 1 / (1 + Math.exp(-sigmoidInput));\n    return isFinite(sigmoidOutput) ? sigmoidOutput : 0.5;\n  }\n\n  /**\n   * Calculate adaptive threshold based on signal characteristics\n   */\n  static calculateAdaptiveThreshold(amplitudes) {\n    if (amplitudes.length === 0) return 10;\n    const sorted = [...amplitudes].sort((a, b) => a - b);\n    const q1 = sorted[Math.floor(amplitudes.length * 0.25)];\n    const q3 = sorted[Math.floor(amplitudes.length * 0.75)];\n    const iqr = q3 - q1;\n\n    // Adaptive threshold based on interquartile range\n    // Clean signals typically have small IQR, noisy signals have large IQR\n    return Math.max(3, Math.min(25, iqr * 2 + 5));\n  }\n\n  /**\n   * Enhanced signal smoothness analysis\n   */\n  static calculateSignalSmoothness(amplitudes) {\n    if (amplitudes.length < 3) return 0;\n    let totalVariation = 0;\n    for (let i = 1; i < amplitudes.length - 1; i++) {\n      // Second derivative approximation (measure of \"jaggedness\")\n      const secondDerivative = amplitudes[i + 1] - 2 * amplitudes[i] + amplitudes[i - 1];\n      totalVariation += Math.abs(secondDerivative);\n    }\n    const avgVariation = totalVariation / (amplitudes.length - 2);\n    // Sigmoid transformation for better separation\n    return 1 / (1 + Math.exp(-0.5 * (avgVariation - 3)));\n  }\n\n  /**\n   * Dynamic range analysis\n   */\n  static calculateDynamicRange(amplitudes) {\n    if (amplitudes.length === 0) return 0;\n    const sorted = [...amplitudes].sort((a, b) => a - b);\n    const min = sorted[0];\n    const max = sorted[sorted.length - 1];\n    const range = max - min;\n\n    // Very clean signals often have consistent levels (low range)\n    // Very noisy signals have extreme variations (high range)\n    const normalizedRange = Math.min(range / 50, 1); // Assume 50dB max reasonable range\n    return normalizedRange;\n  }\n\n  /**\n   * Simple noisiness calculation for cases with limited data\n   * Now almost entirely based on average amplitude (95%)\n   */\n  static calculateSimpleNoisiness(amplitudes) {\n    if (amplitudes.length === 0) return 50;\n\n    // Calculate average amplitude score (dominant factor)\n    const averageAmplitudeScore = this.calculateAverageAmplitudeScore(amplitudes);\n\n    // Simple standard deviation based calculation (minimal factor)\n    const mean = amplitudes.reduce((sum, val) => sum + val, 0) / amplitudes.length;\n    const variance = amplitudes.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / amplitudes.length;\n    const stdDev = Math.sqrt(variance);\n\n    // Enhanced scaling with sigmoid for better separation\n    const normalizedStdDev = stdDev / 8; // Adaptive to typical EMC data\n    const varianceScore = 100 / (1 + Math.exp(-2 * (normalizedStdDev - 1)));\n    const varianceNormalized = Math.max(5, Math.min(95, varianceScore)) / 100;\n\n    // Almost entirely based on average amplitude (95%) with minimal variance (5%)\n    const combinedScore = averageAmplitudeScore * 0.95 + varianceNormalized * 0.05;\n    const finalScore = Math.round(combinedScore * 100);\n    return Math.max(5, Math.min(95, finalScore));\n  }\n\n  /**\n   * Calculate variance-based noise score with adaptive scaling\n   */\n  static calculateVarianceScore(amplitudes) {\n    if (amplitudes.length === 0) return 0;\n\n    // Filter out any non-finite values\n    const validAmplitudes = amplitudes.filter(amp => isFinite(amp));\n    if (validAmplitudes.length === 0) return 0;\n    const mean = validAmplitudes.reduce((sum, val) => sum + val, 0) / validAmplitudes.length;\n    const variance = validAmplitudes.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / validAmplitudes.length;\n    const stdDev = Math.sqrt(variance);\n\n    // Enhanced adaptive scaling based on signal characteristics\n    // Use sigmoid function for better separation\n    const adaptiveThreshold = this.calculateAdaptiveThreshold(validAmplitudes);\n    const normalizedStdDev = stdDev / adaptiveThreshold;\n\n    // Sigmoid transformation for better dynamic range (0-1)\n    const score = 1 / (1 + Math.exp(-3 * (normalizedStdDev - 1)));\n    return isFinite(score) ? score : 0;\n  }\n\n  /**\n   * Enhanced peak-to-RMS analysis with crest factor and distribution analysis\n   */\n  static calculatePeakToRmsRatio(amplitudes) {\n    if (amplitudes.length === 0) return 0;\n\n    // Filter out any non-finite values\n    const validAmplitudes = amplitudes.filter(amp => isFinite(amp));\n    if (validAmplitudes.length === 0) return 0;\n    const peak = Math.max(...validAmplitudes);\n    const rms = Math.sqrt(validAmplitudes.reduce((sum, val) => sum + val * val, 0) / validAmplitudes.length);\n    if (!isFinite(peak) || !isFinite(rms) || rms === 0) return 0;\n    const crestFactor = peak / rms;\n    if (!isFinite(crestFactor)) return 0;\n\n    // Enhanced analysis: combine crest factor with distribution characteristics\n    const mean = validAmplitudes.reduce((sum, val) => sum + val, 0) / validAmplitudes.length;\n    const skewness = this.calculateSkewness(validAmplitudes, mean);\n\n    // Clean signals: high crest factor + low skewness\n    // Noisy signals: low crest factor + high skewness\n    const crestScore = 1 / (1 + Math.exp(-0.5 * (crestFactor - 4))); // Sigmoid around crest factor of 4\n    const skewnessScore = Math.abs(skewness) / 3; // Normalize skewness influence\n\n    // Combined score (inverted because lower = more noise for final calculation)\n    const combinedScore = crestScore * 0.7 + (1 - skewnessScore) * 0.3;\n    return Math.max(0, Math.min(1, combinedScore));\n  }\n\n  /**\n   * Calculate skewness of amplitude distribution\n   */\n  static calculateSkewness(amplitudes, mean) {\n    if (amplitudes.length === 0) return 0;\n    const variance = amplitudes.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / amplitudes.length;\n    const stdDev = Math.sqrt(variance);\n    if (stdDev === 0) return 0;\n    const skewness = amplitudes.reduce((sum, val) => sum + Math.pow((val - mean) / stdDev, 3), 0) / amplitudes.length;\n    return isFinite(skewness) ? skewness : 0;\n  }\n\n  /**\n   * Calculate spectral flatness (0-1, higher = flatter/noisier)\n   */\n  static calculateSpectralFlatness(amplitudes) {\n    if (amplitudes.length === 0) return 0;\n\n    // Convert to linear scale for calculation, ensuring no zero values\n    const linearAmplitudes = amplitudes.map(amp => {\n      const linear = Math.pow(10, amp / 20);\n      return Math.max(linear, 1e-12); // Prevent zero values\n    });\n\n    // Calculate geometric mean using log-space to avoid overflow/underflow\n    const logSum = linearAmplitudes.reduce((sum, val) => {\n      const logVal = Math.log(val);\n      return sum + (isFinite(logVal) ? logVal : -27.6); // log(1e-12) â‰ˆ -27.6\n    }, 0);\n    const geometricMean = Math.exp(logSum / linearAmplitudes.length);\n\n    // Arithmetic mean\n    const arithmeticMean = linearAmplitudes.reduce((sum, val) => sum + val, 0) / linearAmplitudes.length;\n\n    // Ensure we don't divide by zero and result is finite\n    if (!isFinite(geometricMean) || !isFinite(arithmeticMean) || arithmeticMean === 0) {\n      return 0;\n    }\n    const flatness = geometricMean / arithmeticMean;\n    return isFinite(flatness) ? Math.min(flatness, 1) : 0;\n  }\n\n  /**\n   * Calculate high-frequency content ratio\n   */\n  static calculateHighFrequencyContent(data) {\n    if (data.length < 4) return 0;\n\n    // Filter out any points with non-finite values\n    const validData = data.filter(point => isFinite(point.frequency) && isFinite(point.amplitude));\n    if (validData.length < 4) return 0;\n    const sortedByFreq = [...validData].sort((a, b) => a.frequency - b.frequency);\n    const totalRange = sortedByFreq[sortedByFreq.length - 1].frequency - sortedByFreq[0].frequency;\n    if (totalRange === 0 || !isFinite(totalRange)) return 0;\n\n    // Define \"high frequency\" as top 25% of the frequency range\n    const highFreqThreshold = sortedByFreq[0].frequency + totalRange * 0.75;\n    const highFreqPoints = validData.filter(point => point.frequency >= highFreqThreshold);\n    const lowFreqPoints = validData.filter(point => point.frequency < highFreqThreshold);\n    if (lowFreqPoints.length === 0 || highFreqPoints.length === 0) return 0;\n    const highFreqMean = highFreqPoints.reduce((sum, p) => sum + p.amplitude, 0) / highFreqPoints.length;\n    const lowFreqMean = lowFreqPoints.reduce((sum, p) => sum + p.amplitude, 0) / lowFreqPoints.length;\n    if (!isFinite(highFreqMean) || !isFinite(lowFreqMean) || lowFreqMean === 0) return 0;\n\n    // High frequency content relative to low frequency content\n    const ratio = highFreqMean / lowFreqMean;\n    if (!isFinite(ratio)) return 0;\n\n    // Normalize to 0-1 scale - higher ratio suggests more high-freq noise\n    const score = Math.min(Math.max(0, (ratio - 0.5) / 1.5), 1);\n    return isFinite(score) ? score : 0;\n  }\n\n  /**\n   * Calculate density of small peaks (noise spikes)\n   */\n  static calculateSmallPeakDensity(amplitudes) {\n    if (amplitudes.length < 5) return 0;\n\n    // Filter out any non-finite values\n    const validAmplitudes = amplitudes.filter(amp => isFinite(amp));\n    if (validAmplitudes.length < 5) return 0;\n    let peakCount = 0;\n    const threshold = 2; // dB threshold for considering a peak\n\n    for (let i = 2; i < validAmplitudes.length - 2; i++) {\n      const current = validAmplitudes[i];\n      const leftAvg = (validAmplitudes[i - 1] + validAmplitudes[i - 2]) / 2;\n      const rightAvg = (validAmplitudes[i + 1] + validAmplitudes[i + 2]) / 2;\n\n      // Ensure all values are finite\n      if (!isFinite(current) || !isFinite(leftAvg) || !isFinite(rightAvg)) continue;\n\n      // Check if current point is a local peak above threshold\n      if (current > leftAvg + threshold && current > rightAvg + threshold) {\n        peakCount++;\n      }\n    }\n\n    // Density of peaks per 100 data points\n    const density = peakCount / validAmplitudes.length * 100;\n    if (!isFinite(density)) return 0;\n\n    // Normalize to 0-1 scale - more peaks suggest more noise\n    const score = Math.min(density / 10, 1); // Assume 10 peaks per 100 points = very noisy\n    return isFinite(score) ? score : 0;\n  }\n\n  /**\n   * Enhanced metric combination with better discrimination\n   */\n  static combineEnhancedMetrics(metrics) {\n    // Simplified weighting - average amplitude is now the dominant factor\n    const weights = {\n      averageAmplitude: 0.95,\n      // 95% - average amplitude (DOMINANT factor)\n      varianceScore: 0.02,\n      // 2% - minimal variance influence\n      peakToRmsRatio: 0.01,\n      // 1% - minimal peak ratio influence\n      spectralFlatness: 0.01,\n      // 1% - minimal spectral influence\n      highFreqContent: 0.005,\n      // 0.5% - minimal high-freq influence\n      smallPeakDensity: 0.005,\n      // 0.5% - minimal peak density influence\n      signalSmoothness: 0.0,\n      // 0% - disabled\n      dynamicRange: 0.0 // 0% - disabled\n    };\n\n    // Ensure all metric values are finite before combining\n    const safeAverageAmplitude = isFinite(metrics.averageAmplitude) ? metrics.averageAmplitude : 0.5;\n    const safeVariance = isFinite(metrics.varianceScore) ? metrics.varianceScore : 0.5;\n    const safePeakRms = isFinite(metrics.peakToRmsRatio) ? metrics.peakToRmsRatio : 0.5;\n    const safeFlatness = isFinite(metrics.spectralFlatness) ? metrics.spectralFlatness : 0.5;\n    const safeHighFreq = isFinite(metrics.highFreqContent) ? metrics.highFreqContent : 0.5;\n    const safePeakDensity = isFinite(metrics.smallPeakDensity) ? metrics.smallPeakDensity : 0.5;\n    const safeSmoothness = isFinite(metrics.signalSmoothness) ? metrics.signalSmoothness : 0.5;\n    const safeDynamicRange = isFinite(metrics.dynamicRange) ? metrics.dynamicRange : 0.5;\n    const weightedSum = safeAverageAmplitude * weights.averageAmplitude + safeVariance * weights.varianceScore + safePeakRms * weights.peakToRmsRatio + safeFlatness * weights.spectralFlatness + safeHighFreq * weights.highFreqContent + safePeakDensity * weights.smallPeakDensity + safeSmoothness * weights.signalSmoothness + safeDynamicRange * weights.dynamicRange;\n\n    // Apply final sigmoid transformation for enhanced separation\n    // This spreads out the middle values more effectively\n    const sigmoidInput = (weightedSum - 0.5) * 4; // Scale and center around 0\n    const sigmoidOutput = 1 / (1 + Math.exp(-sigmoidInput));\n\n    // Convert to 0-100 scale with enhanced dynamic range\n    const result = sigmoidOutput * 100;\n    return isFinite(result) ? Math.max(1, Math.min(99, result)) : 50;\n  }\n\n  /**\n   * Assess confidence in the noisiness calculation\n   */\n  static assessConfidence(dataLength, frequencies) {\n    const freqRange = Math.max(...frequencies) - Math.min(...frequencies);\n    if (dataLength >= 1000 && freqRange > 0) return 'high';\n    if (dataLength >= 100 && freqRange > 0) return 'medium';\n    return 'low';\n  }\n\n  /**\n   * Categorize noisiness level\n   */\n  static categorizeNoisiness(noisiness) {\n    if (noisiness <= 20) return 'very_quiet';\n    if (noisiness <= 40) return 'quiet';\n    if (noisiness <= 60) return 'moderate';\n    if (noisiness <= 80) return 'noisy';\n    return 'very_noisy';\n  }\n\n  /**\n   * Get color for noisiness visualization\n   */\n  static getNoisinessColor(noisiness) {\n    if (noisiness <= 20) return '#2ecc71'; // Green - very quiet\n    if (noisiness <= 40) return '#27ae60'; // Dark green - quiet  \n    if (noisiness <= 60) return '#f39c12'; // Orange - moderate\n    if (noisiness <= 80) return '#e67e22'; // Dark orange - noisy\n    return '#e74c3c'; // Red - very noisy\n  }\n\n  /**\n   * Get emoji for noisiness level\n   */\n  static getNoisinessEmoji(noisiness) {\n    if (noisiness <= 20) return 'ðŸ”‡'; // Very quiet\n    if (noisiness <= 40) return 'ðŸ”‰'; // Quiet\n    if (noisiness <= 60) return 'ðŸ”Š'; // Moderate\n    if (noisiness <= 80) return 'ðŸ“¢'; // Noisy\n    return 'ðŸš¨'; // Very noisy\n  }\n\n  /**\n   * Get text description for noisiness level\n   */\n  static getNoisinessDescription(noisiness) {\n    if (noisiness <= 20) return 'Very Quiet';\n    if (noisiness <= 40) return 'Quiet';\n    if (noisiness <= 60) return 'Moderate';\n    if (noisiness <= 80) return 'Noisy';\n    return 'Very Noisy';\n  }\n\n  /**\n   * Batch analyze multiple files and rank by noisiness\n   */\n  static async batchAnalyzeAndRank(files) {\n    const results = files.map(file => this.calculateNoisinessIndex(file.data, file.filename));\n\n    // Sort by noisiness (highest first)\n    return results.sort((a, b) => b.noisinessIndex - a.noisinessIndex);\n  }\n}","map":{"version":3,"names":["NoiseAnalysisService","calculateNoisinessIndex","data","filename","length","amplitudes","map","point","amplitude","filter","amp","isFinite","averageAmplitude","calculateAverageAmplitudeScore","fallbackScore","Math","round","noisinessIndex","metrics","varianceScore","peakToRmsRatio","spectralFlatness","highFreqContent","smallPeakDensity","overallNoisiness","confidence","category","frequencies","frequency","freq","simpleVariance","calculateSimpleNoisiness","combinedScore","finalScore","categorizeNoisiness","calculateVarianceScore","calculatePeakToRmsRatio","calculateSpectralFlatness","calculateHighFrequencyContent","calculateSmallPeakDensity","signalSmoothness","calculateSignalSmoothness","dynamicRange","calculateDynamicRange","combineEnhancedMetrics","finalNoisiness","max","min","assessConfidence","validAmplitudes","reduce","sum","val","minExpectedAmplitude","maxExpectedAmplitude","normalizedAmplitude","clampedNormalized","sigmoidInput","sigmoidOutput","exp","calculateAdaptiveThreshold","sorted","sort","a","b","q1","floor","q3","iqr","totalVariation","i","secondDerivative","abs","avgVariation","range","normalizedRange","averageAmplitudeScore","mean","variance","pow","stdDev","sqrt","normalizedStdDev","varianceNormalized","adaptiveThreshold","score","peak","rms","crestFactor","skewness","calculateSkewness","crestScore","skewnessScore","linearAmplitudes","linear","logSum","logVal","log","geometricMean","arithmeticMean","flatness","validData","sortedByFreq","totalRange","highFreqThreshold","highFreqPoints","lowFreqPoints","highFreqMean","p","lowFreqMean","ratio","peakCount","threshold","current","leftAvg","rightAvg","density","weights","safeAverageAmplitude","safeVariance","safePeakRms","safeFlatness","safeHighFreq","safePeakDensity","safeSmoothness","safeDynamicRange","weightedSum","result","dataLength","freqRange","noisiness","getNoisinessColor","getNoisinessEmoji","getNoisinessDescription","batchAnalyzeAndRank","files","results","file"],"sources":["/Users/howardwang/Desktop/Turner Engineering/Software Product Design/reda-main/typescript-react-app/src/services/NoiseAnalysisService.ts"],"sourcesContent":["// ========================================================================\n// REDA EMC Testing Tool - Noise Analysis Service\n// ========================================================================\n// Turner Engineering Corporation - Professional EMC Testing Support\n// \n// Service for analyzing signal noisiness and calculating noisiness indices\n// ========================================================================\n\nimport { CsvDataPoint } from '../types';\n\n// ========================================================================\n// NOISE ANALYSIS INTERFACES\n// ========================================================================\n\nexport interface NoisinessMetrics {\n  averageAmplitude: number;    // 0-1, higher = higher average amplitude (primary noisiness indicator)\n  varianceScore: number;       // 0-1, higher = more variance/noise\n  peakToRmsRatio: number;      // Lower values indicate more noise\n  spectralFlatness: number;    // 0-1, higher = flatter spectrum (more noise)\n  highFreqContent: number;     // 0-1, higher = more high-freq noise\n  smallPeakDensity: number;    // 0-1, higher = more noise spikes\n  overallNoisiness: number;    // 0-100, final noisiness index\n}\n\nexport interface NoiseAnalysisResult {\n  filename: string;\n  noisinessIndex: number;      // 0-100 scale\n  metrics: NoisinessMetrics;\n  confidence: 'high' | 'medium' | 'low';\n  category: 'very_quiet' | 'quiet' | 'moderate' | 'noisy' | 'very_noisy';\n}\n\n// ========================================================================\n// NOISE ANALYSIS SERVICE\n// ========================================================================\n\nexport class NoiseAnalysisService {\n  \n  /**\n   * Calculate comprehensive noisiness index for signal data\n   */\n  static calculateNoisinessIndex(\n    data: CsvDataPoint[], \n    filename: string = 'unknown'\n  ): NoiseAnalysisResult {\n    \n    if (!data || data.length < 10) {\n      // Calculate average amplitude even with limited data if possible\n      const amplitudes = data?.map(point => point.amplitude).filter(amp => isFinite(amp)) || [];\n      const averageAmplitude = amplitudes.length > 0 ? this.calculateAverageAmplitudeScore(amplitudes) : 0;\n      const fallbackScore = amplitudes.length > 0 ? Math.round(averageAmplitude * 95 + 5) : 50; // 95% average amplitude, 5% base\n      \n      return {\n        filename,\n        noisinessIndex: fallbackScore,\n        metrics: {\n          averageAmplitude,\n          varianceScore: 0,\n          peakToRmsRatio: 0,\n          spectralFlatness: 0,\n          highFreqContent: 0,\n          smallPeakDensity: 0,\n          overallNoisiness: fallbackScore\n        },\n        confidence: 'low',\n        category: 'moderate'\n      };\n    }\n\n    const amplitudes = data.map(point => point.amplitude).filter(amp => isFinite(amp));\n    const frequencies = data.map(point => point.frequency).filter(freq => isFinite(freq));\n    \n    // Early validation - if we don't have enough valid data, use simplified calculation\n    if (amplitudes.length < 10) {\n      const averageAmplitude = this.calculateAverageAmplitudeScore(amplitudes);\n      const simpleVariance = this.calculateSimpleNoisiness(amplitudes);\n      \n      // Almost entirely based on average amplitude (95%) with minimal variance (5%)\n      const combinedScore = averageAmplitude * 0.95 + (simpleVariance / 100) * 0.05;\n      const finalScore = Math.round(combinedScore * 100);\n      \n      return {\n        filename,\n        noisinessIndex: finalScore,\n        metrics: {\n          averageAmplitude,\n          varianceScore: simpleVariance / 100,\n          peakToRmsRatio: 0.5,\n          spectralFlatness: 0.5,\n          highFreqContent: 0.5,\n          smallPeakDensity: 0.5,\n          overallNoisiness: finalScore\n        },\n        confidence: 'low',\n        category: this.categorizeNoisiness(finalScore)\n      };\n    }\n    \n    // Calculate enhanced metrics for better discrimination\n    const averageAmplitude = this.calculateAverageAmplitudeScore(amplitudes);\n    const varianceScore = this.calculateVarianceScore(amplitudes);\n    const peakToRmsRatio = this.calculatePeakToRmsRatio(amplitudes);\n    const spectralFlatness = this.calculateSpectralFlatness(amplitudes);\n    const highFreqContent = this.calculateHighFrequencyContent(data);\n    const smallPeakDensity = this.calculateSmallPeakDensity(amplitudes);\n    \n    // Additional discriminating metrics\n    const signalSmoothness = this.calculateSignalSmoothness(amplitudes);\n    const dynamicRange = this.calculateDynamicRange(amplitudes);\n    \n    // Enhanced weighted combination prioritizing average amplitude for noisiness\n    const overallNoisiness = this.combineEnhancedMetrics({\n      averageAmplitude,\n      varianceScore,\n      peakToRmsRatio,\n      spectralFlatness,\n      highFreqContent,\n      smallPeakDensity,\n      signalSmoothness,\n      dynamicRange\n    });\n\n    const metrics: NoisinessMetrics = {\n      averageAmplitude,\n      varianceScore,\n      peakToRmsRatio,\n      spectralFlatness,\n      highFreqContent,\n      smallPeakDensity,\n      overallNoisiness\n    };\n\n    // Ensure the final noisiness index is finite and within bounds\n    const finalNoisiness = isFinite(overallNoisiness) ? Math.round(Math.max(0, Math.min(100, overallNoisiness))) : 50;\n\n    return {\n      filename,\n      noisinessIndex: finalNoisiness,\n      metrics,\n      confidence: this.assessConfidence(data.length, frequencies),\n      category: this.categorizeNoisiness(finalNoisiness)\n    };\n  }\n\n  /**\n   * Calculate average amplitude score (0-1, higher = higher average amplitude = noisier)\n   * This is the primary metric for determining noisiness based on average amplitude values\n   */\n  private static calculateAverageAmplitudeScore(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 0;\n    \n    // Filter out any non-finite values\n    const validAmplitudes = amplitudes.filter(amp => isFinite(amp));\n    if (validAmplitudes.length === 0) return 0;\n    \n    // Calculate simple average amplitude\n    const averageAmplitude = validAmplitudes.reduce((sum, val) => sum + val, 0) / validAmplitudes.length;\n    \n    if (!isFinite(averageAmplitude)) return 0;\n    \n    // Normalize average amplitude to 0-1 scale\n    // EMC data typically ranges from very low (quiet) to high (noisy) amplitudes\n    // We use a sigmoid function to map average amplitude to noisiness score\n    // Assume amplitudes typically range from -80dB to +20dB, with higher values being noisier\n    const minExpectedAmplitude = -80; // dB - very quiet signal\n    const maxExpectedAmplitude = 20;  // dB - very noisy signal\n    \n    // Normalize to 0-1 range\n    const normalizedAmplitude = (averageAmplitude - minExpectedAmplitude) / (maxExpectedAmplitude - minExpectedAmplitude);\n    \n    // Apply sigmoid transformation for smooth transition\n    // Values closer to maxExpectedAmplitude will be closer to 1 (noisier)\n    const clampedNormalized = Math.max(0, Math.min(1, normalizedAmplitude));\n    \n    // Use a sigmoid to enhance the separation between different amplitude levels\n    const sigmoidInput = (clampedNormalized - 0.5) * 6; // Scale for steeper curve\n    const sigmoidOutput = 1 / (1 + Math.exp(-sigmoidInput));\n    \n    return isFinite(sigmoidOutput) ? sigmoidOutput : 0.5;\n  }\n\n  /**\n   * Calculate adaptive threshold based on signal characteristics\n   */\n  private static calculateAdaptiveThreshold(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 10;\n    \n    const sorted = [...amplitudes].sort((a, b) => a - b);\n    const q1 = sorted[Math.floor(amplitudes.length * 0.25)];\n    const q3 = sorted[Math.floor(amplitudes.length * 0.75)];\n    const iqr = q3 - q1;\n    \n    // Adaptive threshold based on interquartile range\n    // Clean signals typically have small IQR, noisy signals have large IQR\n    return Math.max(3, Math.min(25, iqr * 2 + 5));\n  }\n\n  /**\n   * Enhanced signal smoothness analysis\n   */\n  private static calculateSignalSmoothness(amplitudes: number[]): number {\n    if (amplitudes.length < 3) return 0;\n    \n    let totalVariation = 0;\n    for (let i = 1; i < amplitudes.length - 1; i++) {\n      // Second derivative approximation (measure of \"jaggedness\")\n      const secondDerivative = amplitudes[i+1] - 2*amplitudes[i] + amplitudes[i-1];\n      totalVariation += Math.abs(secondDerivative);\n    }\n    \n    const avgVariation = totalVariation / (amplitudes.length - 2);\n    // Sigmoid transformation for better separation\n    return 1 / (1 + Math.exp(-0.5 * (avgVariation - 3)));\n  }\n\n  /**\n   * Dynamic range analysis\n   */\n  private static calculateDynamicRange(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 0;\n    \n    const sorted = [...amplitudes].sort((a, b) => a - b);\n    const min = sorted[0];\n    const max = sorted[sorted.length - 1];\n    const range = max - min;\n    \n    // Very clean signals often have consistent levels (low range)\n    // Very noisy signals have extreme variations (high range)\n    const normalizedRange = Math.min(range / 50, 1); // Assume 50dB max reasonable range\n    return normalizedRange;\n  }\n\n  /**\n   * Simple noisiness calculation for cases with limited data\n   * Now almost entirely based on average amplitude (95%)\n   */\n  private static calculateSimpleNoisiness(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 50;\n    \n    // Calculate average amplitude score (dominant factor)\n    const averageAmplitudeScore = this.calculateAverageAmplitudeScore(amplitudes);\n    \n    // Simple standard deviation based calculation (minimal factor)\n    const mean = amplitudes.reduce((sum, val) => sum + val, 0) / amplitudes.length;\n    const variance = amplitudes.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / amplitudes.length;\n    const stdDev = Math.sqrt(variance);\n    \n    // Enhanced scaling with sigmoid for better separation\n    const normalizedStdDev = stdDev / 8; // Adaptive to typical EMC data\n    const varianceScore = 100 / (1 + Math.exp(-2 * (normalizedStdDev - 1)));\n    const varianceNormalized = Math.max(5, Math.min(95, varianceScore)) / 100;\n    \n    // Almost entirely based on average amplitude (95%) with minimal variance (5%)\n    const combinedScore = averageAmplitudeScore * 0.95 + varianceNormalized * 0.05;\n    const finalScore = Math.round(combinedScore * 100);\n    \n    return Math.max(5, Math.min(95, finalScore));\n  }\n\n  /**\n   * Calculate variance-based noise score with adaptive scaling\n   */\n  private static calculateVarianceScore(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 0;\n    \n    // Filter out any non-finite values\n    const validAmplitudes = amplitudes.filter(amp => isFinite(amp));\n    if (validAmplitudes.length === 0) return 0;\n    \n    const mean = validAmplitudes.reduce((sum, val) => sum + val, 0) / validAmplitudes.length;\n    const variance = validAmplitudes.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / validAmplitudes.length;\n    const stdDev = Math.sqrt(variance);\n    \n    // Enhanced adaptive scaling based on signal characteristics\n    // Use sigmoid function for better separation\n    const adaptiveThreshold = this.calculateAdaptiveThreshold(validAmplitudes);\n    const normalizedStdDev = stdDev / adaptiveThreshold;\n    \n    // Sigmoid transformation for better dynamic range (0-1)\n    const score = 1 / (1 + Math.exp(-3 * (normalizedStdDev - 1)));\n    return isFinite(score) ? score : 0;\n  }\n\n  /**\n   * Enhanced peak-to-RMS analysis with crest factor and distribution analysis\n   */\n  private static calculatePeakToRmsRatio(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 0;\n    \n    // Filter out any non-finite values\n    const validAmplitudes = amplitudes.filter(amp => isFinite(amp));\n    if (validAmplitudes.length === 0) return 0;\n    \n    const peak = Math.max(...validAmplitudes);\n    const rms = Math.sqrt(validAmplitudes.reduce((sum, val) => sum + val * val, 0) / validAmplitudes.length);\n    \n    if (!isFinite(peak) || !isFinite(rms) || rms === 0) return 0;\n    \n    const crestFactor = peak / rms;\n    if (!isFinite(crestFactor)) return 0;\n    \n    // Enhanced analysis: combine crest factor with distribution characteristics\n    const mean = validAmplitudes.reduce((sum, val) => sum + val, 0) / validAmplitudes.length;\n    const skewness = this.calculateSkewness(validAmplitudes, mean);\n    \n    // Clean signals: high crest factor + low skewness\n    // Noisy signals: low crest factor + high skewness\n    const crestScore = 1 / (1 + Math.exp(-0.5 * (crestFactor - 4))); // Sigmoid around crest factor of 4\n    const skewnessScore = Math.abs(skewness) / 3; // Normalize skewness influence\n    \n    // Combined score (inverted because lower = more noise for final calculation)\n    const combinedScore = (crestScore * 0.7 + (1 - skewnessScore) * 0.3);\n    return Math.max(0, Math.min(1, combinedScore));\n  }\n\n  /**\n   * Calculate skewness of amplitude distribution\n   */\n  private static calculateSkewness(amplitudes: number[], mean: number): number {\n    if (amplitudes.length === 0) return 0;\n    \n    const variance = amplitudes.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / amplitudes.length;\n    const stdDev = Math.sqrt(variance);\n    \n    if (stdDev === 0) return 0;\n    \n    const skewness = amplitudes.reduce((sum, val) => sum + Math.pow((val - mean) / stdDev, 3), 0) / amplitudes.length;\n    return isFinite(skewness) ? skewness : 0;\n  }\n\n  /**\n   * Calculate spectral flatness (0-1, higher = flatter/noisier)\n   */\n  private static calculateSpectralFlatness(amplitudes: number[]): number {\n    if (amplitudes.length === 0) return 0;\n    \n    // Convert to linear scale for calculation, ensuring no zero values\n    const linearAmplitudes = amplitudes.map(amp => {\n      const linear = Math.pow(10, amp / 20);\n      return Math.max(linear, 1e-12); // Prevent zero values\n    });\n    \n    // Calculate geometric mean using log-space to avoid overflow/underflow\n    const logSum = linearAmplitudes.reduce((sum, val) => {\n      const logVal = Math.log(val);\n      return sum + (isFinite(logVal) ? logVal : -27.6); // log(1e-12) â‰ˆ -27.6\n    }, 0);\n    const geometricMean = Math.exp(logSum / linearAmplitudes.length);\n    \n    // Arithmetic mean\n    const arithmeticMean = linearAmplitudes.reduce((sum, val) => sum + val, 0) / linearAmplitudes.length;\n    \n    // Ensure we don't divide by zero and result is finite\n    if (!isFinite(geometricMean) || !isFinite(arithmeticMean) || arithmeticMean === 0) {\n      return 0;\n    }\n    \n    const flatness = geometricMean / arithmeticMean;\n    return isFinite(flatness) ? Math.min(flatness, 1) : 0;\n  }\n\n  /**\n   * Calculate high-frequency content ratio\n   */\n  private static calculateHighFrequencyContent(data: CsvDataPoint[]): number {\n    if (data.length < 4) return 0;\n    \n    // Filter out any points with non-finite values\n    const validData = data.filter(point => \n      isFinite(point.frequency) && isFinite(point.amplitude)\n    );\n    \n    if (validData.length < 4) return 0;\n    \n    const sortedByFreq = [...validData].sort((a, b) => a.frequency - b.frequency);\n    const totalRange = sortedByFreq[sortedByFreq.length - 1].frequency - sortedByFreq[0].frequency;\n    \n    if (totalRange === 0 || !isFinite(totalRange)) return 0;\n    \n    // Define \"high frequency\" as top 25% of the frequency range\n    const highFreqThreshold = sortedByFreq[0].frequency + totalRange * 0.75;\n    \n    const highFreqPoints = validData.filter(point => point.frequency >= highFreqThreshold);\n    const lowFreqPoints = validData.filter(point => point.frequency < highFreqThreshold);\n    \n    if (lowFreqPoints.length === 0 || highFreqPoints.length === 0) return 0;\n    \n    const highFreqMean = highFreqPoints.reduce((sum, p) => sum + p.amplitude, 0) / highFreqPoints.length;\n    const lowFreqMean = lowFreqPoints.reduce((sum, p) => sum + p.amplitude, 0) / lowFreqPoints.length;\n    \n    if (!isFinite(highFreqMean) || !isFinite(lowFreqMean) || lowFreqMean === 0) return 0;\n    \n    // High frequency content relative to low frequency content\n    const ratio = highFreqMean / lowFreqMean;\n    \n    if (!isFinite(ratio)) return 0;\n    \n    // Normalize to 0-1 scale - higher ratio suggests more high-freq noise\n    const score = Math.min(Math.max(0, (ratio - 0.5) / 1.5), 1);\n    return isFinite(score) ? score : 0;\n  }\n\n  /**\n   * Calculate density of small peaks (noise spikes)\n   */\n  private static calculateSmallPeakDensity(amplitudes: number[]): number {\n    if (amplitudes.length < 5) return 0;\n    \n    // Filter out any non-finite values\n    const validAmplitudes = amplitudes.filter(amp => isFinite(amp));\n    if (validAmplitudes.length < 5) return 0;\n    \n    let peakCount = 0;\n    const threshold = 2; // dB threshold for considering a peak\n    \n    for (let i = 2; i < validAmplitudes.length - 2; i++) {\n      const current = validAmplitudes[i];\n      const leftAvg = (validAmplitudes[i-1] + validAmplitudes[i-2]) / 2;\n      const rightAvg = (validAmplitudes[i+1] + validAmplitudes[i+2]) / 2;\n      \n      // Ensure all values are finite\n      if (!isFinite(current) || !isFinite(leftAvg) || !isFinite(rightAvg)) continue;\n      \n      // Check if current point is a local peak above threshold\n      if (current > leftAvg + threshold && current > rightAvg + threshold) {\n        peakCount++;\n      }\n    }\n    \n    // Density of peaks per 100 data points\n    const density = (peakCount / validAmplitudes.length) * 100;\n    \n    if (!isFinite(density)) return 0;\n    \n    // Normalize to 0-1 scale - more peaks suggest more noise\n    const score = Math.min(density / 10, 1); // Assume 10 peaks per 100 points = very noisy\n    return isFinite(score) ? score : 0;\n  }\n\n  /**\n   * Enhanced metric combination with better discrimination\n   */\n  private static combineEnhancedMetrics(metrics: {\n    averageAmplitude: number;\n    varianceScore: number;\n    peakToRmsRatio: number;\n    spectralFlatness: number;\n    highFreqContent: number;\n    smallPeakDensity: number;\n    signalSmoothness: number;\n    dynamicRange: number;\n  }): number {\n    // Simplified weighting - average amplitude is now the dominant factor\n    const weights = {\n      averageAmplitude: 0.95,      // 95% - average amplitude (DOMINANT factor)\n      varianceScore: 0.02,         // 2% - minimal variance influence\n      peakToRmsRatio: 0.01,        // 1% - minimal peak ratio influence\n      spectralFlatness: 0.01,      // 1% - minimal spectral influence\n      highFreqContent: 0.005,      // 0.5% - minimal high-freq influence\n      smallPeakDensity: 0.005,     // 0.5% - minimal peak density influence\n      signalSmoothness: 0.0,       // 0% - disabled\n      dynamicRange: 0.0            // 0% - disabled\n    };\n    \n    // Ensure all metric values are finite before combining\n    const safeAverageAmplitude = isFinite(metrics.averageAmplitude) ? metrics.averageAmplitude : 0.5;\n    const safeVariance = isFinite(metrics.varianceScore) ? metrics.varianceScore : 0.5;\n    const safePeakRms = isFinite(metrics.peakToRmsRatio) ? metrics.peakToRmsRatio : 0.5;\n    const safeFlatness = isFinite(metrics.spectralFlatness) ? metrics.spectralFlatness : 0.5;\n    const safeHighFreq = isFinite(metrics.highFreqContent) ? metrics.highFreqContent : 0.5;\n    const safePeakDensity = isFinite(metrics.smallPeakDensity) ? metrics.smallPeakDensity : 0.5;\n    const safeSmoothness = isFinite(metrics.signalSmoothness) ? metrics.signalSmoothness : 0.5;\n    const safeDynamicRange = isFinite(metrics.dynamicRange) ? metrics.dynamicRange : 0.5;\n    \n    const weightedSum = \n      safeAverageAmplitude * weights.averageAmplitude +\n      safeVariance * weights.varianceScore +\n      safePeakRms * weights.peakToRmsRatio +\n      safeFlatness * weights.spectralFlatness +\n      safeHighFreq * weights.highFreqContent +\n      safePeakDensity * weights.smallPeakDensity +\n      safeSmoothness * weights.signalSmoothness +\n      safeDynamicRange * weights.dynamicRange;\n    \n    // Apply final sigmoid transformation for enhanced separation\n    // This spreads out the middle values more effectively\n    const sigmoidInput = (weightedSum - 0.5) * 4; // Scale and center around 0\n    const sigmoidOutput = 1 / (1 + Math.exp(-sigmoidInput));\n    \n    // Convert to 0-100 scale with enhanced dynamic range\n    const result = sigmoidOutput * 100;\n    return isFinite(result) ? Math.max(1, Math.min(99, result)) : 50;\n  }\n\n  /**\n   * Assess confidence in the noisiness calculation\n   */\n  private static assessConfidence(\n    dataLength: number, \n    frequencies: number[]\n  ): 'high' | 'medium' | 'low' {\n    const freqRange = Math.max(...frequencies) - Math.min(...frequencies);\n    \n    if (dataLength >= 1000 && freqRange > 0) return 'high';\n    if (dataLength >= 100 && freqRange > 0) return 'medium';\n    return 'low';\n  }\n\n  /**\n   * Categorize noisiness level\n   */\n  private static categorizeNoisiness(noisiness: number): NoiseAnalysisResult['category'] {\n    if (noisiness <= 20) return 'very_quiet';\n    if (noisiness <= 40) return 'quiet';\n    if (noisiness <= 60) return 'moderate';\n    if (noisiness <= 80) return 'noisy';\n    return 'very_noisy';\n  }\n\n  /**\n   * Get color for noisiness visualization\n   */\n  static getNoisinessColor(noisiness: number): string {\n    if (noisiness <= 20) return '#2ecc71'; // Green - very quiet\n    if (noisiness <= 40) return '#27ae60'; // Dark green - quiet  \n    if (noisiness <= 60) return '#f39c12'; // Orange - moderate\n    if (noisiness <= 80) return '#e67e22'; // Dark orange - noisy\n    return '#e74c3c'; // Red - very noisy\n  }\n\n  /**\n   * Get emoji for noisiness level\n   */\n  static getNoisinessEmoji(noisiness: number): string {\n    if (noisiness <= 20) return 'ðŸ”‡'; // Very quiet\n    if (noisiness <= 40) return 'ðŸ”‰'; // Quiet\n    if (noisiness <= 60) return 'ðŸ”Š'; // Moderate\n    if (noisiness <= 80) return 'ðŸ“¢'; // Noisy\n    return 'ðŸš¨'; // Very noisy\n  }\n\n  /**\n   * Get text description for noisiness level\n   */\n  static getNoisinessDescription(noisiness: number): string {\n    if (noisiness <= 20) return 'Very Quiet';\n    if (noisiness <= 40) return 'Quiet';\n    if (noisiness <= 60) return 'Moderate';\n    if (noisiness <= 80) return 'Noisy';\n    return 'Very Noisy';\n  }\n\n  /**\n   * Batch analyze multiple files and rank by noisiness\n   */\n  static async batchAnalyzeAndRank(\n    files: Array<{ filename: string; data: CsvDataPoint[] }>\n  ): Promise<NoiseAnalysisResult[]> {\n    const results = files.map(file => \n      this.calculateNoisinessIndex(file.data, file.filename)\n    );\n    \n    // Sort by noisiness (highest first)\n    return results.sort((a, b) => b.noisinessIndex - a.noisinessIndex);\n  }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}