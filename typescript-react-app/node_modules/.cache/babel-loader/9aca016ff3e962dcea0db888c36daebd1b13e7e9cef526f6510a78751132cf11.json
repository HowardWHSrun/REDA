{"ast":null,"code":"// ========================================================================\n// REDA EMC Testing Tool - CSV Service\n// ========================================================================\n// Turner Engineering Corporation - Professional EMC Testing Support\n// \n// Service for CSV file processing, data parsing, and analysis\n// ========================================================================\n\nimport { BAND_DEFINITIONS, APP_CONFIG, ERROR_MESSAGES, DEFAULT_PEAK_DETECTION_OPTIONS, SUPPORTED_CSV_TYPES } from '../constants';\n\n// ========================================================================\n// CSV PARSING AND VALIDATION\n// ========================================================================\n\nexport class CsvService {\n  /**\n   * Parse CSV file content and extract frequency/amplitude data\n   */\n  static async parseCsvFile(file) {\n    const result = {\n      success: false,\n      data: undefined,\n      errors: [],\n      warnings: []\n    };\n    try {\n      // Validate file type\n      if (!this.isValidCsvFile(file)) {\n        result.errors.push(ERROR_MESSAGES.UNSUPPORTED_FILE_TYPE);\n        return result;\n      }\n\n      // Validate file size\n      if (file.size > APP_CONFIG.maxFileSize) {\n        result.errors.push(ERROR_MESSAGES.FILE_TOO_LARGE);\n        return result;\n      }\n\n      // Parse CSV content\n      const csvText = await this.readFileAsText(file);\n      const parseResult = await this.parseCsvText(csvText);\n      if (!parseResult.success || !parseResult.data) {\n        result.errors.push(...parseResult.errors);\n        return result;\n      }\n      result.success = true;\n      result.data = parseResult.data;\n      result.warnings = parseResult.warnings;\n    } catch (error) {\n      result.errors.push(`Failed to parse CSV file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n    return result;\n  }\n\n  /**\n   * Parse CSV text content\n   */\n  static async parseCsvText(csvText) {\n    const result = {\n      success: false,\n      data: undefined,\n      errors: [],\n      warnings: []\n    };\n    try {\n      // Find data start line (look for \"DATA\" marker)\n      const lines = csvText.split('\\n');\n      let dataStartIndex = -1;\n      for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (line === 'DATA' || line === 'DATA,') {\n          dataStartIndex = i + 1;\n          break;\n        }\n      }\n\n      // If no DATA marker found, assume data starts from first line\n      if (dataStartIndex === -1) {\n        dataStartIndex = 0;\n        result.warnings.push('No DATA marker found. Processing from first line.');\n      }\n\n      // Parse data lines\n      const dataPoints = [];\n      let invalidRows = 0;\n      for (let i = dataStartIndex; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line || line.startsWith('#') || line.startsWith('//')) {\n          continue; // Skip empty lines and comments\n        }\n        const parts = line.split(',');\n        if (parts.length >= 2) {\n          const frequency = this.parseNumber(parts[0]);\n          const amplitude = this.parseNumber(parts[1]);\n          if (!isNaN(frequency) && !isNaN(amplitude)) {\n            dataPoints.push({\n              frequency: frequency,\n              // Hz\n              amplitude: amplitude // dBÎ¼V/m\n            });\n          } else {\n            invalidRows++;\n          }\n        } else {\n          invalidRows++;\n        }\n      }\n      if (dataPoints.length === 0) {\n        result.errors.push(ERROR_MESSAGES.NO_DATA_FOUND);\n        return result;\n      }\n      if (invalidRows > 0) {\n        result.warnings.push(`${invalidRows} invalid rows were skipped`);\n      }\n\n      // Sort by frequency\n      dataPoints.sort((a, b) => a.frequency - b.frequency);\n      result.success = true;\n      result.data = dataPoints;\n    } catch (error) {\n      result.errors.push(`Failed to parse CSV text: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n    return result;\n  }\n\n  /**\n   * Analyze CSV file for band detection and validation\n   */\n  static analyzeFile(file, csvData) {\n    const analysis = {\n      filename: file.name,\n      band: null,\n      frequencyRange: {\n        min: 0,\n        max: 0\n      },\n      dataPoints: 0,\n      isValid: false,\n      errors: []\n    };\n    try {\n      // Basic file validation\n      if (!this.isValidCsvFile(file)) {\n        analysis.errors.push('Invalid file type');\n        return analysis;\n      }\n      if (file.size > APP_CONFIG.maxFileSize) {\n        analysis.errors.push('File too large');\n        return analysis;\n      }\n\n      // If CSV data is provided, analyze it\n      if (csvData && csvData.length > 0) {\n        const frequencies = csvData.map(point => point.frequency / 1e6); // Convert to MHz\n        analysis.frequencyRange.min = Math.min(...frequencies);\n        analysis.frequencyRange.max = Math.max(...frequencies);\n        analysis.dataPoints = csvData.length;\n        analysis.band = this.detectBandFromFrequencyRange(analysis.frequencyRange.min, analysis.frequencyRange.max);\n        analysis.isValid = true;\n      } else {\n        // Try to detect band from filename\n        analysis.band = this.detectBandFromFilename(file.name);\n      }\n    } catch (error) {\n      analysis.errors.push(`Analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n    return analysis;\n  }\n\n  /**\n   * Create CSV overlay dataset from file\n   */\n  static async createOverlayDataset(file, color, label) {\n    const result = {\n      success: false,\n      data: undefined,\n      errors: [],\n      warnings: []\n    };\n    try {\n      const parseResult = await this.parseCsvFile(file);\n      if (!parseResult.success || !parseResult.data) {\n        result.errors.push(...parseResult.errors);\n        return result;\n      }\n      const data = parseResult.data;\n      const frequencyData = data.map(point => point.frequency / 1e6); // Convert to MHz\n      const amplitudeData = data.map(point => point.amplitude);\n      const dataset = {\n        id: `dataset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        filename: file.name,\n        data: data,\n        color: color,\n        frequencyData: frequencyData,\n        amplitudeData: amplitudeData,\n        visible: true,\n        label: label || file.name\n      };\n      result.success = true;\n      result.data = dataset;\n      result.warnings = parseResult.warnings;\n    } catch (error) {\n      result.errors.push(`Failed to create overlay dataset: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n    return result;\n  }\n\n  // ========================================================================\n  // PEAK DETECTION\n  // ========================================================================\n\n  /**\n   * Detect peaks in CSV data\n   */\n  static detectPeaks(data, options = DEFAULT_PEAK_DETECTION_OPTIONS) {\n    if (data.length < 3) return [];\n    const peaks = [];\n    const amplitudes = data.map(point => point.amplitude);\n    const frequencies = data.map(point => point.frequency / 1e6); // Convert to MHz\n\n    // Find local maxima\n    for (let i = 1; i < data.length - 1; i++) {\n      const current = amplitudes[i];\n      const prev = amplitudes[i - 1];\n      const next = amplitudes[i + 1];\n\n      // Check if it's a local maximum\n      if (current > prev && current > next && current >= options.minHeight) {\n        const prominence = this.calculateProminence(amplitudes, i);\n        if (prominence >= options.minProminence) {\n          // Check minimum distance from other peaks\n          const tooClose = peaks.some(peak => Math.abs(peak.index - i) < options.minDistance);\n          if (!tooClose) {\n            peaks.push({\n              frequency: frequencies[i],\n              amplitude: current,\n              index: i,\n              prominence: prominence\n            });\n          }\n        }\n      }\n    }\n\n    // Sort by prominence (highest first) and limit to maxPeaks\n    return peaks.sort((a, b) => b.prominence - a.prominence).slice(0, options.maxPeaks);\n  }\n\n  /**\n   * Calculate prominence of a peak\n   */\n  static calculateProminence(amplitudes, peakIndex) {\n    const peakValue = amplitudes[peakIndex];\n    let leftMin = peakValue;\n    let rightMin = peakValue;\n\n    // Search left for minimum\n    for (let i = peakIndex - 1; i >= 0; i--) {\n      if (amplitudes[i] < leftMin) {\n        leftMin = amplitudes[i];\n      }\n      if (amplitudes[i] > peakValue) break;\n    }\n\n    // Search right for minimum\n    for (let i = peakIndex + 1; i < amplitudes.length; i++) {\n      if (amplitudes[i] < rightMin) {\n        rightMin = amplitudes[i];\n      }\n      if (amplitudes[i] > peakValue) break;\n    }\n    return peakValue - Math.max(leftMin, rightMin);\n  }\n\n  // ========================================================================\n  // BAND DETECTION\n  // ========================================================================\n\n  /**\n   * Detect band from frequency range\n   */\n  static detectBandFromFrequencyRange(minFreqMHz, maxFreqMHz) {\n    const bandEntries = Object.entries(BAND_DEFINITIONS);\n    for (const [bandType, definition] of bandEntries) {\n      // Check if the frequency range overlaps with the band\n      if (!(maxFreqMHz < definition.startMHz || minFreqMHz > definition.endMHz)) {\n        return bandType;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Detect band from filename\n   */\n  static detectBandFromFilename(filename) {\n    const upperFilename = filename.toUpperCase();\n\n    // Look for band patterns in filename\n    const bandPatterns = [['B0', [/B0/i, /BAND\\s*0/i, /10\\s*KHZ/i, /160\\s*KHZ/i]], ['B1', [/B1/i, /BAND\\s*1/i, /150\\s*KHZ/i, /650\\s*KHZ/i]], ['B2', [/B2/i, /BAND\\s*2/i, /500\\s*KHZ/i, /3\\s*MHZ/i]], ['B3', [/B3/i, /BAND\\s*3/i, /2\\.?5\\s*MHZ/i, /7\\.?5\\s*MHZ/i]], ['B4', [/B4/i, /BAND\\s*4/i, /5\\s*MHZ/i, /30\\s*MHZ/i]], ['B5', [/B5/i, /BAND\\s*5/i, /25\\s*MHZ/i, /325\\s*MHZ/i]], ['B6', [/B6/i, /BAND\\s*6/i, /300\\s*MHZ/i, /1\\.?3\\s*GHZ/i]], ['B7', [/B7/i, /BAND\\s*7/i, /1\\s*GHZ/i, /6\\s*GHZ/i]]];\n    for (const [bandType, patterns] of bandPatterns) {\n      if (patterns.some(pattern => pattern.test(upperFilename))) {\n        return bandType;\n      }\n    }\n    return null;\n  }\n\n  // ========================================================================\n  // UTILITY METHODS\n  // ========================================================================\n\n  /**\n   * Check if file is a valid CSV file\n   */\n  static isValidCsvFile(file) {\n    return SUPPORTED_CSV_TYPES.includes(file.type) || file.name.toLowerCase().endsWith('.csv') || file.name.toLowerCase().endsWith('.txt');\n  }\n\n  /**\n   * Read file as text\n   */\n  static readFileAsText(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = () => resolve(reader.result);\n      reader.onerror = () => reject(new Error('Failed to read file'));\n      reader.readAsText(file);\n    });\n  }\n\n  /**\n   * Parse string to number with better error handling\n   */\n  static parseNumber(str) {\n    if (!str || typeof str !== 'string') return NaN;\n\n    // Remove any whitespace and common units\n    const cleaned = str.trim().replace(/[^\\d.+eE-]/g, '') // Keep only digits, decimal, signs, and scientific notation\n    .replace(/^0+/, '0'); // Remove leading zeros but keep at least one\n\n    return parseFloat(cleaned);\n  }\n\n  /**\n   * Generate nice axis ranges for plotting\n   */\n  static calculateNiceRanges(minFreq, maxFreq, minAmp, maxAmp) {\n    // Add 5% padding to frequency range\n    const freqPadding = (maxFreq - minFreq) * 0.05;\n    const niceMinFreq = Math.max(0, minFreq - freqPadding);\n    const niceMaxFreq = maxFreq + freqPadding;\n\n    // Add 10% padding to amplitude range\n    const ampPadding = (maxAmp - minAmp) * 0.1;\n    const niceMinAmp = minAmp - ampPadding;\n    const niceMaxAmp = maxAmp + ampPadding;\n    return {\n      frequency: {\n        min: niceMinFreq,\n        max: niceMaxFreq\n      },\n      amplitude: {\n        min: niceMinAmp,\n        max: niceMaxAmp\n      }\n    };\n  }\n\n  /**\n   * Filter data to a specific band range\n   */\n  static filterDataToBand(data, band) {\n    const definition = BAND_DEFINITIONS[band];\n    const startHz = definition.startMHz * 1e6;\n    const endHz = definition.endMHz * 1e6;\n    return data.filter(point => point.frequency >= startHz && point.frequency <= endHz);\n  }\n\n  /**\n   * Export CSV data to file\n   */\n  static exportToCSV(datasets, includeHeader = true) {\n    if (datasets.length === 0) return '';\n    let csvContent = '';\n\n    // Add header if requested\n    if (includeHeader) {\n      csvContent += '# REDA EMC Testing Tool Export\\n';\n      csvContent += `# Generated: ${new Date().toISOString()}\\n`;\n      csvContent += `# Datasets: ${datasets.length}\\n`;\n      csvContent += '#\\n';\n    }\n\n    // Add data header\n    const headers = ['Frequency (Hz)', 'Amplitude (dBÎ¼V/m)', 'Dataset'];\n    csvContent += headers.join(',') + '\\n';\n\n    // Add data\n    for (const dataset of datasets) {\n      for (const point of dataset.data) {\n        csvContent += `${point.frequency},${point.amplitude},\"${dataset.filename}\"\\n`;\n      }\n    }\n    return csvContent;\n  }\n\n  /**\n   * Generate filename suggestions based on content\n   */\n  static generateFilename(band, runId, timestamp) {\n    const parts = ['reda_export'];\n    if (band) parts.push(band.toLowerCase());\n    if (runId) parts.push(runId);\n    const date = timestamp || new Date();\n    const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD\n    parts.push(dateStr);\n    return parts.join('_') + '.csv';\n  }\n}","map":{"version":3,"names":["BAND_DEFINITIONS","APP_CONFIG","ERROR_MESSAGES","DEFAULT_PEAK_DETECTION_OPTIONS","SUPPORTED_CSV_TYPES","CsvService","parseCsvFile","file","result","success","data","undefined","errors","warnings","isValidCsvFile","push","UNSUPPORTED_FILE_TYPE","size","maxFileSize","FILE_TOO_LARGE","csvText","readFileAsText","parseResult","parseCsvText","error","Error","message","lines","split","dataStartIndex","i","length","line","trim","dataPoints","invalidRows","startsWith","parts","frequency","parseNumber","amplitude","isNaN","NO_DATA_FOUND","sort","a","b","analyzeFile","csvData","analysis","filename","name","band","frequencyRange","min","max","isValid","frequencies","map","point","Math","detectBandFromFrequencyRange","detectBandFromFilename","createOverlayDataset","color","label","frequencyData","amplitudeData","dataset","id","Date","now","random","toString","substr","visible","detectPeaks","options","peaks","amplitudes","current","prev","next","minHeight","prominence","calculateProminence","minProminence","tooClose","some","peak","abs","index","minDistance","slice","maxPeaks","peakIndex","peakValue","leftMin","rightMin","minFreqMHz","maxFreqMHz","bandEntries","Object","entries","bandType","definition","startMHz","endMHz","upperFilename","toUpperCase","bandPatterns","patterns","pattern","test","includes","type","toLowerCase","endsWith","Promise","resolve","reject","reader","FileReader","onload","onerror","readAsText","str","NaN","cleaned","replace","parseFloat","calculateNiceRanges","minFreq","maxFreq","minAmp","maxAmp","freqPadding","niceMinFreq","niceMaxFreq","ampPadding","niceMinAmp","niceMaxAmp","filterDataToBand","startHz","endHz","filter","exportToCSV","datasets","includeHeader","csvContent","toISOString","headers","join","generateFilename","runId","timestamp","date","dateStr"],"sources":["/Users/howardwang/Desktop/Turner Engineering/Software Product Design/reda-main/typescript-react-app/src/services/CsvService.ts"],"sourcesContent":["// ========================================================================\n// REDA EMC Testing Tool - CSV Service\n// ========================================================================\n// Turner Engineering Corporation - Professional EMC Testing Support\n// \n// Service for CSV file processing, data parsing, and analysis\n// ========================================================================\n\nimport {\n  CsvDataPoint,\n  CsvOverlayDataset,\n  FileAnalysis,\n  BandType,\n  ServiceResult,\n  DetectedPeak,\n  PeakDetectionOptions\n} from '../types';\nimport {\n  BAND_DEFINITIONS,\n  APP_CONFIG,\n  ERROR_MESSAGES,\n  DEFAULT_PEAK_DETECTION_OPTIONS,\n  SUPPORTED_CSV_TYPES\n} from '../constants';\n\n// ========================================================================\n// CSV PARSING AND VALIDATION\n// ========================================================================\n\nexport class CsvService {\n  /**\n   * Parse CSV file content and extract frequency/amplitude data\n   */\n  static async parseCsvFile(file: File): Promise<ServiceResult<CsvDataPoint[]>> {\n    const result: ServiceResult<CsvDataPoint[]> = {\n      success: false,\n      data: undefined,\n      errors: [],\n      warnings: []\n    };\n\n    try {\n      // Validate file type\n      if (!this.isValidCsvFile(file)) {\n        result.errors.push(ERROR_MESSAGES.UNSUPPORTED_FILE_TYPE);\n        return result;\n      }\n\n      // Validate file size\n      if (file.size > APP_CONFIG.maxFileSize) {\n        result.errors.push(ERROR_MESSAGES.FILE_TOO_LARGE);\n        return result;\n      }\n\n      // Parse CSV content\n      const csvText = await this.readFileAsText(file);\n      const parseResult = await this.parseCsvText(csvText);\n\n      if (!parseResult.success || !parseResult.data) {\n        result.errors.push(...parseResult.errors);\n        return result;\n      }\n\n      result.success = true;\n      result.data = parseResult.data;\n      result.warnings = parseResult.warnings;\n\n    } catch (error) {\n      result.errors.push(`Failed to parse CSV file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Parse CSV text content\n   */\n  static async parseCsvText(csvText: string): Promise<ServiceResult<CsvDataPoint[]>> {\n    const result: ServiceResult<CsvDataPoint[]> = {\n      success: false,\n      data: undefined,\n      errors: [],\n      warnings: []\n    };\n\n    try {\n      // Find data start line (look for \"DATA\" marker)\n      const lines = csvText.split('\\n');\n      let dataStartIndex = -1;\n\n      for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (line === 'DATA' || line === 'DATA,') {\n          dataStartIndex = i + 1;\n          break;\n        }\n      }\n\n      // If no DATA marker found, assume data starts from first line\n      if (dataStartIndex === -1) {\n        dataStartIndex = 0;\n        result.warnings.push('No DATA marker found. Processing from first line.');\n      }\n\n      // Parse data lines\n      const dataPoints: CsvDataPoint[] = [];\n      let invalidRows = 0;\n\n      for (let i = dataStartIndex; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line || line.startsWith('#') || line.startsWith('//')) {\n          continue; // Skip empty lines and comments\n        }\n\n        const parts = line.split(',');\n        if (parts.length >= 2) {\n          const frequency = this.parseNumber(parts[0]);\n          const amplitude = this.parseNumber(parts[1]);\n\n          if (!isNaN(frequency) && !isNaN(amplitude)) {\n            dataPoints.push({\n              frequency: frequency, // Hz\n              amplitude: amplitude  // dBÎ¼V/m\n            });\n          } else {\n            invalidRows++;\n          }\n        } else {\n          invalidRows++;\n        }\n      }\n\n      if (dataPoints.length === 0) {\n        result.errors.push(ERROR_MESSAGES.NO_DATA_FOUND);\n        return result;\n      }\n\n      if (invalidRows > 0) {\n        result.warnings.push(`${invalidRows} invalid rows were skipped`);\n      }\n\n      // Sort by frequency\n      dataPoints.sort((a, b) => a.frequency - b.frequency);\n\n      result.success = true;\n      result.data = dataPoints;\n\n    } catch (error) {\n      result.errors.push(`Failed to parse CSV text: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Analyze CSV file for band detection and validation\n   */\n  static analyzeFile(file: File, csvData?: CsvDataPoint[]): FileAnalysis {\n    const analysis: FileAnalysis = {\n      filename: file.name,\n      band: null,\n      frequencyRange: { min: 0, max: 0 },\n      dataPoints: 0,\n      isValid: false,\n      errors: []\n    };\n\n    try {\n      // Basic file validation\n      if (!this.isValidCsvFile(file)) {\n        analysis.errors.push('Invalid file type');\n        return analysis;\n      }\n\n      if (file.size > APP_CONFIG.maxFileSize) {\n        analysis.errors.push('File too large');\n        return analysis;\n      }\n\n      // If CSV data is provided, analyze it\n      if (csvData && csvData.length > 0) {\n        const frequencies = csvData.map(point => point.frequency / 1e6); // Convert to MHz\n        analysis.frequencyRange.min = Math.min(...frequencies);\n        analysis.frequencyRange.max = Math.max(...frequencies);\n        analysis.dataPoints = csvData.length;\n        analysis.band = this.detectBandFromFrequencyRange(\n          analysis.frequencyRange.min,\n          analysis.frequencyRange.max\n        );\n        analysis.isValid = true;\n      } else {\n        // Try to detect band from filename\n        analysis.band = this.detectBandFromFilename(file.name);\n      }\n\n    } catch (error) {\n      analysis.errors.push(`Analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    return analysis;\n  }\n\n  /**\n   * Create CSV overlay dataset from file\n   */\n  static async createOverlayDataset(\n    file: File,\n    color: string,\n    label?: string\n  ): Promise<ServiceResult<CsvOverlayDataset>> {\n    const result: ServiceResult<CsvOverlayDataset> = {\n      success: false,\n      data: undefined,\n      errors: [],\n      warnings: []\n    };\n\n    try {\n      const parseResult = await this.parseCsvFile(file);\n      \n      if (!parseResult.success || !parseResult.data) {\n        result.errors.push(...parseResult.errors);\n        return result;\n      }\n\n      const data = parseResult.data;\n      const frequencyData = data.map(point => point.frequency / 1e6); // Convert to MHz\n      const amplitudeData = data.map(point => point.amplitude);\n\n      const dataset: CsvOverlayDataset = {\n        id: `dataset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        filename: file.name,\n        data: data,\n        color: color,\n        frequencyData: frequencyData,\n        amplitudeData: amplitudeData,\n        visible: true,\n        label: label || file.name\n      };\n\n      result.success = true;\n      result.data = dataset;\n      result.warnings = parseResult.warnings;\n\n    } catch (error) {\n      result.errors.push(`Failed to create overlay dataset: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    return result;\n  }\n\n  // ========================================================================\n  // PEAK DETECTION\n  // ========================================================================\n\n  /**\n   * Detect peaks in CSV data\n   */\n  static detectPeaks(\n    data: CsvDataPoint[],\n    options: PeakDetectionOptions = DEFAULT_PEAK_DETECTION_OPTIONS\n  ): DetectedPeak[] {\n    if (data.length < 3) return [];\n\n    const peaks: DetectedPeak[] = [];\n    const amplitudes = data.map(point => point.amplitude);\n    const frequencies = data.map(point => point.frequency / 1e6); // Convert to MHz\n\n    // Find local maxima\n    for (let i = 1; i < data.length - 1; i++) {\n      const current = amplitudes[i];\n      const prev = amplitudes[i - 1];\n      const next = amplitudes[i + 1];\n\n      // Check if it's a local maximum\n      if (current > prev && current > next && current >= options.minHeight) {\n        const prominence = this.calculateProminence(amplitudes, i);\n        \n        if (prominence >= options.minProminence) {\n          // Check minimum distance from other peaks\n          const tooClose = peaks.some(peak => \n            Math.abs(peak.index - i) < options.minDistance\n          );\n\n          if (!tooClose) {\n            peaks.push({\n              frequency: frequencies[i],\n              amplitude: current,\n              index: i,\n              prominence: prominence\n            });\n          }\n        }\n      }\n    }\n\n    // Sort by prominence (highest first) and limit to maxPeaks\n    return peaks\n      .sort((a, b) => b.prominence - a.prominence)\n      .slice(0, options.maxPeaks);\n  }\n\n  /**\n   * Calculate prominence of a peak\n   */\n  private static calculateProminence(amplitudes: number[], peakIndex: number): number {\n    const peakValue = amplitudes[peakIndex];\n    let leftMin = peakValue;\n    let rightMin = peakValue;\n\n    // Search left for minimum\n    for (let i = peakIndex - 1; i >= 0; i--) {\n      if (amplitudes[i] < leftMin) {\n        leftMin = amplitudes[i];\n      }\n      if (amplitudes[i] > peakValue) break;\n    }\n\n    // Search right for minimum\n    for (let i = peakIndex + 1; i < amplitudes.length; i++) {\n      if (amplitudes[i] < rightMin) {\n        rightMin = amplitudes[i];\n      }\n      if (amplitudes[i] > peakValue) break;\n    }\n\n    return peakValue - Math.max(leftMin, rightMin);\n  }\n\n  // ========================================================================\n  // BAND DETECTION\n  // ========================================================================\n\n  /**\n   * Detect band from frequency range\n   */\n  static detectBandFromFrequencyRange(minFreqMHz: number, maxFreqMHz: number): BandType | null {\n    const bandEntries = Object.entries(BAND_DEFINITIONS) as [BandType, typeof BAND_DEFINITIONS[BandType]][];\n    \n    for (const [bandType, definition] of bandEntries) {\n      // Check if the frequency range overlaps with the band\n      if (!(maxFreqMHz < definition.startMHz || minFreqMHz > definition.endMHz)) {\n        return bandType;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Detect band from filename\n   */\n  static detectBandFromFilename(filename: string): BandType | null {\n    const upperFilename = filename.toUpperCase();\n    \n    // Look for band patterns in filename\n    const bandPatterns: [BandType, RegExp[]][] = [\n      ['B0', [/B0/i, /BAND\\s*0/i, /10\\s*KHZ/i, /160\\s*KHZ/i]],\n      ['B1', [/B1/i, /BAND\\s*1/i, /150\\s*KHZ/i, /650\\s*KHZ/i]],\n      ['B2', [/B2/i, /BAND\\s*2/i, /500\\s*KHZ/i, /3\\s*MHZ/i]],\n      ['B3', [/B3/i, /BAND\\s*3/i, /2\\.?5\\s*MHZ/i, /7\\.?5\\s*MHZ/i]],\n      ['B4', [/B4/i, /BAND\\s*4/i, /5\\s*MHZ/i, /30\\s*MHZ/i]],\n      ['B5', [/B5/i, /BAND\\s*5/i, /25\\s*MHZ/i, /325\\s*MHZ/i]],\n      ['B6', [/B6/i, /BAND\\s*6/i, /300\\s*MHZ/i, /1\\.?3\\s*GHZ/i]],\n      ['B7', [/B7/i, /BAND\\s*7/i, /1\\s*GHZ/i, /6\\s*GHZ/i]]\n    ];\n\n    for (const [bandType, patterns] of bandPatterns) {\n      if (patterns.some(pattern => pattern.test(upperFilename))) {\n        return bandType;\n      }\n    }\n\n    return null;\n  }\n\n  // ========================================================================\n  // UTILITY METHODS\n  // ========================================================================\n\n  /**\n   * Check if file is a valid CSV file\n   */\n  static isValidCsvFile(file: File): boolean {\n    return SUPPORTED_CSV_TYPES.includes(file.type) || \n           file.name.toLowerCase().endsWith('.csv') ||\n           file.name.toLowerCase().endsWith('.txt');\n  }\n\n  /**\n   * Read file as text\n   */\n  static readFileAsText(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = () => resolve(reader.result as string);\n      reader.onerror = () => reject(new Error('Failed to read file'));\n      reader.readAsText(file);\n    });\n  }\n\n  /**\n   * Parse string to number with better error handling\n   */\n  private static parseNumber(str: string): number {\n    if (!str || typeof str !== 'string') return NaN;\n    \n    // Remove any whitespace and common units\n    const cleaned = str.trim()\n      .replace(/[^\\d.+eE-]/g, '') // Keep only digits, decimal, signs, and scientific notation\n      .replace(/^0+/, '0'); // Remove leading zeros but keep at least one\n    \n    return parseFloat(cleaned);\n  }\n\n  /**\n   * Generate nice axis ranges for plotting\n   */\n  static calculateNiceRanges(\n    minFreq: number,\n    maxFreq: number,\n    minAmp: number,\n    maxAmp: number\n  ): {\n    frequency: { min: number; max: number };\n    amplitude: { min: number; max: number };\n  } {\n    // Add 5% padding to frequency range\n    const freqPadding = (maxFreq - minFreq) * 0.05;\n    const niceMinFreq = Math.max(0, minFreq - freqPadding);\n    const niceMaxFreq = maxFreq + freqPadding;\n\n    // Add 10% padding to amplitude range\n    const ampPadding = (maxAmp - minAmp) * 0.1;\n    const niceMinAmp = minAmp - ampPadding;\n    const niceMaxAmp = maxAmp + ampPadding;\n\n    return {\n      frequency: { min: niceMinFreq, max: niceMaxFreq },\n      amplitude: { min: niceMinAmp, max: niceMaxAmp }\n    };\n  }\n\n  /**\n   * Filter data to a specific band range\n   */\n  static filterDataToBand(data: CsvDataPoint[], band: BandType): CsvDataPoint[] {\n    const definition = BAND_DEFINITIONS[band];\n    const startHz = definition.startMHz * 1e6;\n    const endHz = definition.endMHz * 1e6;\n\n    return data.filter(point => \n      point.frequency >= startHz && point.frequency <= endHz\n    );\n  }\n\n  /**\n   * Export CSV data to file\n   */\n  static exportToCSV(\n    datasets: CsvOverlayDataset[],\n    includeHeader: boolean = true\n  ): string {\n    if (datasets.length === 0) return '';\n\n    let csvContent = '';\n\n    // Add header if requested\n    if (includeHeader) {\n      csvContent += '# REDA EMC Testing Tool Export\\n';\n      csvContent += `# Generated: ${new Date().toISOString()}\\n`;\n      csvContent += `# Datasets: ${datasets.length}\\n`;\n      csvContent += '#\\n';\n    }\n\n    // Add data header\n    const headers = ['Frequency (Hz)', 'Amplitude (dBÎ¼V/m)', 'Dataset'];\n    csvContent += headers.join(',') + '\\n';\n\n    // Add data\n    for (const dataset of datasets) {\n      for (const point of dataset.data) {\n        csvContent += `${point.frequency},${point.amplitude},\"${dataset.filename}\"\\n`;\n      }\n    }\n\n    return csvContent;\n  }\n\n  /**\n   * Generate filename suggestions based on content\n   */\n  static generateFilename(\n    band?: BandType,\n    runId?: string,\n    timestamp?: Date\n  ): string {\n    const parts: string[] = ['reda_export'];\n    \n    if (band) parts.push(band.toLowerCase());\n    if (runId) parts.push(runId);\n    \n    const date = timestamp || new Date();\n    const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD\n    parts.push(dateStr);\n    \n    return parts.join('_') + '.csv';\n  }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}